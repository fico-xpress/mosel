(!******************************************************
  File moseltest.mos
  ``````````````````
  General Mosel testing framework

  authors: Y. Colombani
           L. Bertacco

  (c) Copyright 2015-2024 Fair Isaac Corporation

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

*******************************************************!)
model moseltest
version 0.10.1
uses 'mmsystem','mmjobs','mmxml'

parameters
 SRCDIR="alltests"  ! Location of the tests or test file
 TINCL='*'          ! List of file patterns for inclusion
 TEXCL=''           ! List of file patterns for exclusion
 SKIPLABELS=''      ! list of labels to skip
 ONLYLABELS=''      ! list of labels to process (everything else is skipped)
 WKDIR="workdir"    ! Temporary directory for cwd
 NBW=1              ! Number of worker instances
 ASYNCOUT=false     ! When NBW>1: display result asap
 LIBPATH=""         ! Paths to additional dso/bim (same syntax as $PATH)
 BASEREP="report"   ! Report file (after execution, in current directory)
 REPDATED=false     ! Generate unique report file using timestamp
 REPDATEFMT=""      ! Timestamp format for dated report files, eg "%.y%0m%0d%0H%0M%0S"
 REPRESET=true      ! Clear report file (false=>append to existing)
 KEEPDIR=false      ! Keep workdir/dsodir at the end of run
 PIDFILE=""         ! PID file for the xprmsrv server (''=>no xprmsrv)
 XSRVLOG=""         ! Log file for the xprmsrv server
 REPFILE=""         ! Report file (replaces BASEREP when defined) '-' to disable
 MAXWAIT=60*10      ! Maximum time to wait for an execution
 VALGRIND=false     ! Run tests with valgrind
 KEEPENV=false      ! Keep Mosel related environment variables
 LINELEN=80         ! Length of a line in the report
 RFMT=""            ! Reporting format ("","TC","TAP","TAP13","JUNIT")
 MAXLOGLEN=20000    ! Maximum length of a embedded log file. -1 to disable
 SAVELOGS=false     ! Keep example log even when successful
 SHOWLOGS=false     ! Copy default streams to console when running tests
 COLOR=0            ! coloured result: 0:none, 1:normal, 2:bright
 LOGDIR=""          ! If defined, create separate log file per test
 TESTPARAMS=""      ! Parameters to pass to the test models
 HAVENMAKE=true     ! Windows: assume nmake is available (use make otherwise)
 LOGWKR=false       ! report test to worker assignments (for debugging)

 COVLST=""          ! List of package/model/app names for coverage (separated by spaces)
 COVSRC=""          ! Paths to package/model sources (default: LIBPATH)
 COVDIR="coverage"  ! Directory where to save coverage reports
 COVREP=0           ! Format of the reports: 1: annotated source files; 2:lcov info file, 4: cobertura xml file (7:all)
end-parameters

declarations
 CONFLINE="!*!"     ! Tag for configuration lines
 DIRSEP=getdirsep
 PATHSEP=getpathsep
 DATADIR:string     ! Temporary directory for saving data files
 DSODIR:string      ! Temporary dso directory
 OUTDIR:string      ! where log files are stored during tests
 OPTTYPES:array(OPTNAMES:set of string) of string
 Allfiles:list of string  ! Files to tests
 pending:list of string   ! being tested, delayed or waiting for last logging
 delayed: list of string  ! sublist of 'pending' waiting for another test
 srcdir:text
 excludepat=["*.c9"+DIRSEP+"*"]
 labels_skip,labels_only:set of string
 pmvers:dynamic array(string) of integer
 pmvers_txt:dynamic array(string) of text
 output_fd:integer
 cred,cgreen,cyellow,cblack:string

 sysname:string
 sysproc:string
 syshost:string
 sysarch:integer
 sysnaarch:string
 sysnaproc:string
 usenmake:boolean
 repfile:string
 repdate:text
 env_dsodir:text
 env_datadir:text
 env_clspath:text
 env_dsopath:text
 env_bimpfx:text
 TPLEN=LINELEN-22

 s_worker=
        record
	  id:integer
	  tnum:integer          ! test associted to this worker
	  file:string		! file name for this test
	  minst:Mosel
	  mdr:Model
	  workdir:string
	  onceonly:boolean      ! restart after running the example
	  nbtest:integer	! number of tests run by thus worker
	  queue:list of string	! pending tests assigned to this worker
	end-record
 workers:array(wrng:range) of s_worker
 freewks:set of integer

 ! Test status
 TST_DELAYED=-5	! waiting for another test to complete
 TST_READY=-4	! ready to start
 TST_TOSTART=-3	! just before test starts
 TST_RUNNING=-2	! during execution
 TST_TIMEOUT=-1	! after timeout (waiting to end)
 TST_SUCCESS=0
 TST_SKIPPED=1
 TST_ERROR=2	! something went wrong before/after the test
 TST_FAILED=3

 ! Test file type
 TFT_UNKNOWN=-1
 TFT_MOS=0
 TFT_C=1
 TFT_JAVA=2
 TFT_BIM=3

 s_test=
        record
	  num:integer
	  nextingroup:string
	  after:string     ! test to be done before this one
	  filetype:integer ! see TFT_* above
	  opts:dynamic array(set of string) of text
	  label:text
	  wid:integer      ! worker for this test
	  wnbt:integer     ! job number for this worker
	  msg:text
	  status:integer   ! see TST_* above
	  time:real        ! <0 while running
	end-record
 tests:array(testfiles:set of string) of s_test

 s_srcfile=
	record
	  path:text
	  rlines:range
	  nbl,nblh:integer
	  lincov:array(range) of integer
	  nbf,nbfh:integer
	  fctnames:array(range) of string
	  fctstart:array(range) of integer
	end-record
 srcfiles:dynamic array(allsrc:set of string) of s_srcfile
 bim_dirs:list of text
 src_dirs:list of text

 public tfile:text
! System names:
 KNOWNSYSNAMES={"aix","darwin","linux","hp-ux","sunos","windows"}
! A system name may include architecture like aix64/aix32

 rctx:any
 ! Message levels
 MSL_INF=0
 MSL_WAR=1
 MSL_ERR=2

 nbfailed:integer

 ! Report format API
 logmsg:procedure(integer,...)
 fatalerror:procedure(integer,text)
 suitestarted:procedure(text,integer)
 suitefinished:procedure
 logtest:procedure(boolean,s_test)

end-declarations

! Prototypes
declarations
 procedure printbanner
 function getnig(f:string,n:integer):string
 function successors(f:string):list of string
 function chooseworker(fw:set of integer):integer
 procedure fixtestorder(l:list of string)
 procedure logbeforetest(tres:s_test)
 procedure logaftertest(tres:s_test)
 function preparetest(f:string,tres:s_test,totest:text,testdir:text):integer
 procedure begintest(f:string,wid:integer,tres:s_test)
 procedure endtest(tres:s_test)
 procedure attachworker(f:string,tres:s_test)
 procedure detachworker(tres:s_test)
 function mergeparms(p1:text,p2:text):text
 function dorun(tres:s_test,f:text):boolean
 function execmos(wkr:s_worker,torun:text,parms:text):integer
 function dobuild(wkr:s_worker,tobuild:text):boolean
 function gettotest(path:text,incl:text,excl:text):list of string
 function getfltlist(flt:text): list of string
 procedure cleardir(p:text,rmd:boolean)
 procedure copydir(src:text,dst:string)
 function findmain(wkdir:string,totest:text):integer
 function findmodel(wkdir:text,mtt:text):text
 function expandapp(wkdir:text,path:text):text
 procedure gettags(f:text,opts:array(set of string) of text)
 procedure defsetenv
 procedure updenv(env:text,spe:set of string)
 function expenv(ev:text):text
 function isnonempty(f:string):boolean
 function mkuxpath(p:string):text
 function mklabpath(p:string):text
 function outlog(tres:s_test):string
 function errlog(tres:s_test):string
 function toskip(prevstat:integer,tres:s_test):boolean
 function splicfgline(line:text,val:text):string
 function filexists(f:text):boolean
 function direxists(f:text):boolean
 function findpattern(rpat:text,f:text,rtmsg:text):boolean
 function splitlist(t:text,sc:integer):list of text
 function splitlist(t:text):list of text
 function splitset(t:text):set of string
 procedure showlogs(tres:s_test)
 procedure savelogs(tres:s_test)
 procedure setsysdep
 function safeload(wkr:s_worker,bf:text):boolean
 function safecompile(wkr:s_worker,opts:string,src:text,dst:text):integer
 procedure startxsrv
 procedure stopxsrv
 function domake(wkr:s_worker,f:text):boolean
 function getpmvers(p:string):integer
 function logfile2text(f:string):text
 function system_log(cmd:string,args:...):boolean
 function build_lstdir(srcpath:string):list of text
 procedure build_srcfiles(sfs:array(string) of s_srcfile,pkgs:list of text)
 procedure savecovres(wkr:s_worker,sfs:array(sf:set of string) of s_srcfile)
 procedure reportcov(sfs:array(sf:set of string) of s_srcfile,covdir:text,mode:integer)

 procedure tty_init
 procedure tc_init
 procedure tap_init
 procedure tap13_init
 procedure jut_init
end-declarations

! Known tags (types: txt,int,boo,dbl,lst,lns):
! tag lst: same as 'txt' but can appear several times (concatenated - sep=' ')
! tag lsp: same as 'txt' but can appear several times (concatenated - sep=',')
! tag lns: same as 'txt' but can appear several times (concatenated - sep='\n')
 OPTTYPES("runbefore"):="txt"	! model to run before main - exit 2 to skip test
 OPTTYPES("runafter"):="txt"	! model to run after main test
 OPTTYPES("outexpect"):="lns"	! regex to be found in output stream (in order)
 OPTTYPES("errexpect"):="lns"	! regex to be found in error stream (in order)
 OPTTYPES("compstat"):="int"	! expected compilation status (default=0)
 OPTTYPES("componly"):="boo"	! if true: compile only, no execution
 OPTTYPES("runstat"):="int"	! expected run status (default=0)
 OPTTYPES("exitcode"):="int"	! expected exit code (default=0)
 OPTTYPES("restart"):="boo"	! if true: restart instance after this test
 OPTTYPES("newinst"):="boo"	! if true: start a new instance for this test
 OPTTYPES("build"):="lst"	! list of packages/modules to build
 OPTTYPES("package"):="txt"	! =package name => not run, will be saved
 OPTTYPES("module"):="txt"	! =module name => not run, will be saved
 OPTTYPES("copy"):="lst"	! list of files to copy into the working directory
 OPTTYPES("skip"):="boo"	! if true: skip this test
 OPTTYPES("skip_host"):="lst"	! list of host names where test is skipped
 OPTTYPES("skip_sys"):="lst"	! list of system names where test is skipped
 OPTTYPES("only_host"):="lst"	! list of host names where test is run
 OPTTYPES("only_sys"):="lst"	! list of system names where test is run
 OPTTYPES("labels"):="lst"	! list of labels associated to the test
 OPTTYPES("setenv"):="lns"	! environment variable [sys.]<env>=<value>
 OPTTYPES("noerrmsg"):="boo"	! if true: error stream must be clear after run
 OPTTYPES("parms"):="lsp"	! list of parameters passed to the test model
 OPTTYPES("model"):="txt"	! model to run (valid only in a configuration file)
 OPTTYPES("save"):="lns"	! save specified file for use by another test
 OPTTYPES("restore"):="lns"	! restore specified file from a previous test
 OPTTYPES("required"):="lsp"	! list of packages/modules requited to run the test
 OPTTYPES("after"):="txt"	! test that must have complete before this one
 OPTTYPES("sync"):="boo"	! if true: synchronous mode to the group
 finalise(OPTNAMES)

 output_fd:=getfid(F_OUTPUT)
 case RFMT of
  "": tty_init
  "TC": tc_init
  "TAP","TAP14": tap_init
  "TAP13": tap13_init
  "JUNIT": jut_init
  else
    writeln("Moseltest v",getparam("model_version"),
            "\nUnknown reporting format ",RFMT," - supported formats: TC,TAP,TAP13,JUNIT. Aborting")
    exit(1)
 end-case

 labels_skip:=union(t in splitlist(SKIPLABELS,getchar(","))) {string(t)}
 labels_only:=union(t in splitlist(ONLYLABELS,getchar(","))) {string(t)}

 case COLOR of
  1: do
   cred:="\033[31m"
   cgreen:="\033[32m"
   cyellow:="\033[33m"
   cblack:="\033[0m"
  end-do
  2: do
   cred:="\033[91m"
   cgreen:="\033[92m"
   cyellow:="\033[93m"
   cblack:="\033[0m"
  end-do
 end-case

! System specific settings
 setsysdep
 if not exists(pmvers_txt("mosel")) then
  pmvers_txt("mosel"):="?"
  printbanner
  fatalerror(1,"The 'mosel' executable cannot be found")
 end-if

! Here we go
 srcdir:=SRCDIR
 Allfiles:=gettotest(srcdir,TINCL,TEXCL)
 if Allfiles.size<1 then
  printbanner
  fatalerror(1,"Nothing to test")
 end-if
 testfiles:=set(Allfiles)
 finalise(testfiles)
 forall(f in Allfiles,cnt as counter,t=tests(f)) do
  t.num:=cnt
  t.wid:=-1
  t.label:=mklabpath(f)
  t.status:=TST_READY
  t.filetype:=TFT_UNKNOWN
  t.nextingroup:=getnig(f,cnt)
  if getchar(pathsplit(SYS_FNAME,f)) in getchar('0')..getchar('9') and
     t.nextingroup<>'' then
   pending+=[f]
  end-if
 end-do

 fixtestorder(pending)
 reset(pending)

 makedir(WKDIR)
 cleardir(WKDIR,false)
 DSODIR:=WKDIR+DIRSEP+"dso"
 makedir(DSODIR)
 DATADIR:=WKDIR+DIRSEP+"data"
 makedir(DATADIR)
 OUTDIR:=WKDIR+DIRSEP+"logs"
 makedir(OUTDIR)
 
 wrng:=1..if(NBW<2,1,NBW)
 finalise(wrng)
 freewks:=wrng
 forall(i in wrng,wkr=workers(i)) do
  wkr.tnum:=-1
  wkr.id:=i
  wkr.mdr.uid:=i
  wkr.workdir:=WKDIR+DIRSEP+"wk_"+i
  makedir(wkr.workdir)
 end-do

 env_tmpdir:=expandpath(getparam("tmpdir")+"/tmp")
 makedir(env_tmpdir)
 env_srcdir:=expandpath(SRCDIR)
 env_dsodir:=expandpath(DSODIR)
 env_datadir:=expandpath(DATADIR)
 bim_dirs:=build_lstdir(LIBPATH)
 env_dsopath:="."+PATHSEP+jointext(bim_dirs,PATHSEP)+PATHSEP+expandpath(DSODIR)
 env_clspath:=expandpath(getenv("XPRESSDIR")+"/lib/xprm.jar")+PATHSEP+
    expandpath(getenv("XPRESSDIR")+"/lib/xprd.jar")+PATHSEP+
    expandpath(getenv("XPRESSDIR")+"/lib/bindrv.jar")+PATHSEP+'.'
 if KEEPENV then
  env_bimpfx:=getenv("MOSEL_BIM")
  if getenv("MOSEL_DSO")<>"" then
   env_dsopath+=PATHSEP+getenv("MOSEL_DSO")
  end-if
 else
  env_bimpfx:=""
 end-if

 defsetenv

 suitestarted(mklabpath(SRCDIR),Allfiles.size)
 printbanner

 if LOGDIR<>"" and not direxists(LOGDIR) then
  makepath(LOGDIR)
  if getsysstat<>0 or not direxists(LOGDIR) then
   fatalerror(1,"Failed to create '"+LOGDIR+"'")
  end-if
 end-if

 if COVLST.size>0 then
  logmsg(MSL_INF,"Coverage mode enabled")
  src_dirs:=build_lstdir(if(COVSRC="",LIBPATH,COVSRC))
  build_srcfiles(srcfiles,splittext(COVLST," "))
  coverage:=true
 end-if

 startxsrv

 nbfailed:=0
 while(Allfiles.size>0 or pending.size>0) do
  ! Process all events to record test termination
  while(not isqueueempty) do
   evt:=getnextevent
   case evt.class of
     EVENT_END:
	with f=workers(evt.fromuid).file do
	 endtest(tests(f))
         if ASYNCOUT then
          logaftertest(tests(cutelt(pending,findfirst(pending,f))))
         end-if
	end-do
     EVENT_TIMER:
	with evv=integer(evt.value),wkr=workers(evv) do
     	 if wkr.tnum>0 then
	  if tests(wkr.file).status<>TST_TIMEOUT then
	   tests(wkr.file).status:=TST_TIMEOUT
           stop(wkr.mdr)
	   ! give an addition 20s to terminate
           if settimer(evv,20000,false)<>evv then
	    fatalerror(2,"failed to set timer")
	   end-if
	  else
	   ! model had MAXWAIT+20s to complete: kill the instance
           kill(wkr.minst)
	  end-if
	 else
          logmsg(MSL_INF,"Timer event ignored:",evt)
	 end-if
	end-do
     else
      logmsg(MSL_INF,"Event ignored:",evt)
   end-case
  end-do

  ! Log all terminated tests (respecting order)
  while(pending.size>0 and tests(getfirst(pending)).status>=TST_SUCCESS) do
   logaftertest(tests(cutfirst(pending)))
  end-do

  if freewks.size=0 then
   ! no worker available - if something is pending, wait
   if pending.size>0 then
    wait
   ! else we have finished
   end-if
  else
   with wid=chooseworker(freewks) do
    nexttorun:=''
    ! Pick the first test of the queue for the selected worker (if any)
    if workers(wid).queue.size>0 then
     nexttorun:=cutfirst(workers(wid).queue)
    else
     ! then check that any of the delayed tests can be run
     forall(t in delayed)
      if tests(t).after<>'' and tests(tests(t).after).status>=TST_SUCCESS then
       nexttorun:=cutelt(delayed,findfirst(delayed,t))
       break
      end-if
    end-if

    ! Otherwise get the next test from the main list
    if nexttorun='' and Allfiles.size>0 then
     nexttorun:=cutfirst(Allfiles)
     pending+=[nexttorun]
    end-if

    if nexttorun<>'' then
     with tres=tests(nexttorun) do
      begintest(nexttorun,wid,tres)
      if tres.status=TST_DELAYED then
       delayed+=[nexttorun]
      else
       if tres.status<>TST_RUNNING then
        endtest(tres)
        if ASYNCOUT then
         logaftertest(tests(cutelt(pending,findfirst(pending,nexttorun))))
        end-if
       end-if
       ! this test enables synchronous mode: move all successors
       if tres.opts('sync')="true" then
        forall(t in successors(nexttorun),tp=findfirst(Allfiles,t)|tp>0) do
	 workers(wid).queue+=[t]
	 pending+=[t]
         asproc(cutelt(Allfiles,tp))
	end-do
       end-if
      end-if
     end-do
    ! could not find any test to run - wait if any worker is busy
    elif freewks.size<NBW then
     wait
    end-if
   end-do
  end-if
 end-do

 forall(i in wrng)
  disconnect(workers(i).minst)
 stopxsrv
 if KEEPDIR then
  logmsg(MSL_WAR,"Warning: directory '",WKDIR,"' is not deleted")
 else
  cleardir(WKDIR,true)
 end-if

 if SAVELOGS then
  if LOGDIR<>"" then
   logmsg(MSL_INF,"Log files have been saved under '",LOGDIR,"'.")
  elif repfile<>'-' then
   logmsg(MSL_INF,"Log files have been saved in '",repfile,"'.")
  end-if
 end-if

 if coverage then
  reportcov(srcfiles,COVDIR,COVREP)
 end-if

 suitefinished
 exit(if(nbfailed>0,1,0))

!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!*********************************
!* Display program banner
!*********************************
procedure printbanner
 logmsg(MSL_INF,"Moseltest v",getparam("model_version"),"\n",
                "Running Mosel v",pmvers_txt('mosel')," on `",syshost,
                "' (",sysname," ",sysarch,"bit)\n",
                "Tests from: ",SRCDIR,
		if(LOGDIR<>"","\nLog files will be saved under '"+LOGDIR+"'",""),
		if(NBW>1,"\nWorker instances: "+NBW,""),
		if(ONLYLABELS<>'',"\nSelecting only labels: "+ONLYLABELS,""),
		if(SKIPLABELS<>'',"\nSkipping labels: "+SKIPLABELS,""),
		if(TINCL<>"" and TINCL<>"*","\nIncluding only: "+TINCL,""),
		if(TEXCL<>"","\nExcluding: "+TEXCL,""))
end-procedure

!*********************************
!* Find the next test in a group
!*********************************
function getnig(f:string,n:integer):string
 bn:=pathsplit(SYS_DIR,f)
 if bn='.' then
  forall(i in (n+1)..Allfiles.size,nig=Allfiles(i))
   if findtext(nig,DIRSEP,1)=0 then
    returned:=nig
    break
   end-if
 else
  forall(i in (n+1)..Allfiles.size,nig=Allfiles(i))
   if not startswith(nig,bn) then
    break
   elif pathsplit(SYS_DIR,nig)=bn then
    returned:=nig
    break
   end-if
 end-if
end-function

!*****************************************
!* Get the list of successors in a group
!*****************************************
function successors(f:string):list of string
 f:=tests(f).nextingroup
 while(f<>"") do
  returned+=[f]
  f:=tests(f).nextingroup
 end-do
end-function

!**********************************************
!* Choose a worker (priority to worker queues)
!**********************************************
function chooseworker(fw:set of integer):integer
 returned:=getelt(fw)
 forall(w in fw|workers(w).queue.size>0) do
  returned:=w
  break
 end-do
end-function

!***********************************
!* set order of tests from names
!***********************************
procedure fixtestorder(l:list of string)
 forall(f in l) do
  g:=tests(f).nextingroup
  repeat
   tests(g).after:=f
   g:=tests(g).nextingroup
  until g=''
 end-do
end-procedure

!***************************
!* Logging before the test
!***************************
procedure logbeforetest(tres:s_test)
 tres.time:=0
 logtest(true,tres)
 fflush
end-procedure

!***************************
!* Logging after the test
!***************************
procedure logaftertest(tres:s_test)
 if tres.status>=TST_ERROR: nbfailed+=1
 if SAVELOGS or tres.status>TST_SKIPPED: savelogs(tres)
 logtest(false,tres)
 fdelete(outlog(tres))
 fdelete(errlog(tres))
 fflush
end-procedure

!*********************************
!* Prepare test before execution
!*********************************
function preparetest(f:string,tres:s_test,totest:text,testdir:text):integer
 tres.status:=TST_TOSTART
 testdir:='.'
 workdir:=workers(tres.wid).workdir
 cleardir(workdir,false)
 if endswith(f,".mos") then
  fcopy(srcdir+'/'+f,workdir)
  totest:=pathsplit(SYS_FNAME,f,testdir)
  returned:=TFT_MOS
 elif endswith(f,".c") then
  fcopy(srcdir+'/'+f,workdir)
  totest:=pathsplit(SYS_FNAME,f,testdir)
  returned:=TFT_C
 elif endswith(f,".java") then
  fcopy(srcdir+'/'+f,workdir)
  totest:=pathsplit(SYS_FNAME,f,testdir)
  returned:=TFT_JAVA
 elif endswith(f,".tar") then
  untar(srcdir+'/'+f,workdir)
  returned:=findmain(workdir,totest)
 elif endswith(f,".tgz") or endswith(f,".tar.gz")then
  untar("zlib.gzip:"+srcdir+'/'+f,workdir)
  returned:=findmain(workdir,totest)
 elif endswith(f,".zip") then
  unzip(srcdir+'/'+f,workdir)
  returned:=findmain(workdir,totest)
 elif endswith(f,".dir") then
  copydir(srcdir+'/'+f,workdir)
  returned:=findmain(workdir,totest)
 elif endswith(f,".mcf") then
  fcopy(srcdir+'/'+f,workdir)
  totest:=pathsplit(SYS_FNAME,f,testdir)
  returned:=TFT_BIM
 else
  totest:=''
  returned:=TFT_UNKNOWN
  tres.status:=TST_ERROR
  tres.msg:="Unexpected file extention"
 end-if

 if returned>=0 then
  if totest.size>0 then
   gettags(workdir+DIRSEP+totest,tres.opts)
   if returned=TFT_BIM then
    totest:=findmodel(workdir,tres.opts("model"))
   end-if
  end-if

  if totest.size<1 then
   tres.status:=TST_ERROR
   tres.msg:="Main file was not found"
   returned:=TFT_UNKNOWN
  end-if
 elif tres.status<>TST_ERROR then
  tres.status:=TST_ERROR
  tres.msg:="Main file was not found"
 end-if
 tres.filetype:=returned
end-function

!******************
!* Process a test
!******************
procedure begintest(f:string,wid:integer,tres:s_test)
 declarations
  datadir:text
  totest:text
  ft:integer
  testdir:text
  prevstat:integer
 end-declarations

 prevstat:=if(tres.after<>'',tests(tres.after).status,TST_SUCCESS)
 ! predecessor has not completed yet: this test will be delayed
 if prevstat<TST_SUCCESS then
  tres.status:=TST_DELAYED
 else
  tres.wid:=wid
  ft:=preparetest(f,tres,totest,testdir)
  if ft>=0 and tres.opts("after")<>"" then
   if tres.opts("sync")="true" then
     tres.status:=TST_ERROR
     tres.msg:="Tags 'after' and 'sync' cannot be combined"
     ft:=TFT_UNKNOWN
   else
    ! normalise path to the file (relative to current location)
    tafter:=expandpath(srcdir+'/'+pathsplit(SYS_DIR,f)+'/'+tres.opts("after"))
    deltext(tafter,1,env_srcdir.size+1)
    tres.after:=string(tafter)
    if tres.after not in testfiles then
     tres.status:=TST_ERROR
     tres.msg:="Invalid 'after' tag (no test '"+tres.opts("after")+"')"
     ft:=TFT_UNKNOWN
    elif tests(tres.after).num>tres.num then
     tres.status:=TST_ERROR
     tres.msg:="Invalid sequence for 'after' tag '"+tres.opts("after")+"'"
     ft:=TFT_UNKNOWN
    else
     prevstat:=tests(tres.after).status
     if prevstat<TST_SUCCESS then
      ! test requires another test that has not completed yet: delay it
      tres.wid:=-1
      tres.status:=TST_DELAYED
      ft:=TFT_UNKNOWN   ! to skip startup and exit routine
     end-if
    end-if
   end-if
  end-if

  if tres.status<>TST_DELAYED : logbeforetest(tres)

  if ft>=0 and (prevstat=TST_ERROR or prevstat=TST_FAILED) then
   tres.msg:="Predecessor '"+tres.after+"' failed"
   tres.status:=TST_ERROR
  elif ft>=0 and not toskip(prevstat,tres) then
   with opts=tres.opts, wkr=workers(tres.wid) do
    tres.status:=TST_SUCCESS
    if opts("restore")<>"" then
     forall(fc in splitlist(opts("restore"),10)) do
      fcopy(DATADIR+'/'+fc,wkr.workdir)
      if getsysstat<>0 then
        tres.msg:="Failed to restore file '"+fc+"'"
        tres.status:=TST_ERROR
        break
      end-if
     end-do
    end-if

    if tres.status=TST_SUCCESS then
     if testdir<>'.' then
      datadir:=srcdir+'/'+testdir
     else
      datadir:=srcdir
     end-if
     if opts("copy")<>"" then
      forall(fc in splitlist(opts("copy"),44)) do
       fcopy(datadir+'/'+fc,wkr.workdir)
       if getsysstat<>0 then
         tres.msg:="Failed to copy file '"+fc+"'"
         tres.status:=TST_ERROR
         break
       end-if
      end-do
     end-if
    end-if

    if tres.status=TST_SUCCESS then
     attachworker(f,tres)

     rbf:=execmos(wkr,opts("runbefore"),"")
     if rbf=2 then
      tres.msg:="because of \"runbefore\""
      tres.status:=TST_SKIPPED
     elif rbf<>0 then
      tres.msg:="Failed to run the 'runbefore' model"
      tres.status:=TST_ERROR
     elif dobuild(wkr,opts("build")) then
       tres.msg:="Failed to process the build list ("+opts("build")+")"
       tres.status:=TST_ERROR
     else
      if ft=TFT_MOS then					! Mosel file
       bimfile:=(totest-".mos")+".bim"
       c:=safecompile(wkr,if(coverage,"G","g"),totest,bimfile)
       expstat:=if(opts("compstat")<>"",parseint(opts("compstat"),1),0)
       if c<>expstat then
        tres.msg:="Compilation failed"
        tres.status:=TST_FAILED
       elif c=0 then
        if opts("componly")<>"true" and opts("package")="" then
         if(safeload(wkr,bimfile)) then
          tres.msg:="Failed to load bimfile"
          tres.status:=TST_ERROR
         else
          if coverage : setcontrol(wkr.mdr,"runmode","2")
          tres.status:=TST_RUNNING
          run(wkr.mdr,mergeparms(TESTPARAMS,opts("parms")))
         end-if
        elif opts("package")<>"" then
         if not endswith(opts("package"),".bim"): opts("package")+=".bim"
         fcopy(wkr.workdir+"/"+bimfile,DSODIR+"/"+opts("package"))
         if getsysstat<>0 then
           tres.msg:="Failed to save package '"+bimfile+"'"
           tres.status:=TST_ERROR
         end-if
        end-if
       end-if
      elif ft=TFT_BIM then					! Bim file
       if(safeload(wkr,totest)) then
        tres.msg:="Failed to load bimfile"
        tres.status:=TST_ERROR
       else
        if coverage: setcontrol(wkr.mdr,"runmode","2")
        tres.status:=TST_RUNNING
        run(wkr.mdr,mergeparms(TESTPARAMS,opts("parms")))
       end-if
      elif ft=TFT_C then				! C file
       if opts("module")<>"" then
        execfile:=(totest-".c")+".dso"
        if domake(wkr,execfile) then
         tres.msg:="Compilation failed"
         tres.status:=TST_ERROR
        else
         fcopy(wkr.workdir+"/"+execfile,DSODIR+"/"+opts("module"))
         if getsysstat<>0 then
           tres.msg:="Failed to save module '"+execfile+"'"
           tres.status:=TST_ERROR
         end-if
        end-if
       else
        execfile:=(totest-".c")+if(sysname="windows",".exe","")
        if domake(wkr,execfile) then
         tres.msg:="Compilation failed"
         tres.status:=TST_ERROR
        elif dorun(tres,execfile) then
         tres.msg:="Execution error"
         tres.status:=TST_FAILED
        end-if
       end-if
      elif ft=TFT_JAVA then				! Java file
       execfile:=(totest-".java")+".class"
       if domake(wkr,execfile) then
        tres.msg:="Compilation failed"
        tres.status:=TST_ERROR
       elif dorun(tres,execfile) then
        tres.msg:="Execution error"
        tres.status:=TST_FAILED
       end-if
      else
       tres.msg:="Unknown file format"
       tres.status:=TST_ERROR
      end-if
     end-if
    end-if
   end-do
  end-if
 end-if
end-procedure

!****************************************
!* Process test result after execution
!****************************************
procedure endtest(tres:s_test)
 declarations
  rtmsg:text
 end-declarations
 with opts=tres.opts, wkr=workers(tres.wid) do
  expstat:=if(opts("runstat")<>"",parseint(opts("runstat"),1),0)
  expexcde:=if(opts("exitcode")<>"",parseint(opts("exitcode"),1),0)

  if wkr.tnum=tres.num then
   tres.time+=gettime
   if tres.status=TST_TIMEOUT then
    tres.msg:=formattext("Timeout (%ds)",MAXWAIT)
    tres.status:=TST_FAILED
   elif wkr.minst.status<>0 then
    tres.msg:="Mosel crashed"
    tres.status:=TST_ERROR
   elif tres.status=TST_RUNNING and (wkr.mdr.status<>expstat or wkr.mdr.exitcode<>expexcde) then
    tres.msg:="Execution error"
    tres.status:=TST_FAILED
   else
    if tres.status=TST_RUNNING: tres.status:=TST_SUCCESS
    if coverage and (tres.filetype=TFT_MOS or tres.filetype=TFT_BIM) then
     savecovres(wkr,srcfiles)
    end-if
  
    if execmos(wkr,opts("runafter"),"")<>0 then
     tres.msg:="Failed to run the 'runafter' model"
     tres.status:=TST_ERROR
    end-if
   end-if
   detachworker(tres)
   if tres.status<=TST_SKIPPED and wkr.minst.status=-3 then
    tres.msg:="Abnormal instance termination"
    tres.status:=TST_ERROR
   end-if
  end-if
  
  if tres.status=TST_SUCCESS and opts("save")<>"" then
   forall(fc in splitlist(opts("save"),10)) do
    fcopy(wkr.workdir+"/"+fc,DATADIR)
    if getsysstat<>0 then
     tres.msg:="Failed to save '"+fc+"'"
     tres.status:=TST_ERROR
     break
    end-if
   end-do
  end-if

  if tres.status=TST_SUCCESS and findpattern(opts("outexpect"),outlog(tres),rtmsg) then
   tres.msg:=text("Failed to validate 'outexpect' (")+rtmsg+")"
   tres.status:=TST_FAILED
  end-if
  if tres.status=TST_SUCCESS and findpattern(opts("errexpect"),errlog(tres),rtmsg) then
   tres.msg:=text("Failed to validate 'errexpect' (")+rtmsg+")"
   tres.status:=TST_FAILED
  end-if
  if tres.status=TST_SUCCESS and opts("noerrmsg")="true" and isnonempty(errlog(tres)) then
   tres.msg:="Error messages have been displayed"
   tres.status:=TST_FAILED
  end-if

 end-do
end-procedure

!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!****************************************
!* Prepare the Mosel instance for a run
!****************************************
procedure attachworker(f:string,tres:s_test)
 declarations
  spe:set of string
 end-declarations

 with wkr=workers(tres.wid) do
  assert(wkr.tnum<0)

  ! update environment for next run
  updenv(tres.opts("setenv"),spe)
  if wkr.minst.status=0 and (tres.opts("newinst")="true" or spe.size>0) : disconnect(wkr.minst)

  if wkr.minst.status<>0 then
   valgrind:=if(VALGRIND,'valgrind --num-callers=20 ','')
   ! Add instance working directory to dso path
   dsopath:=expandpath(wkr.workdir)+PATHSEP+getenv("MOSEL_DSO")
   setenv("MOSEL_DSO",dsopath)
   if connect(wkr.minst,'rcmd:'+valgrind+'mosel -r -d "'+expandpath(wkr.workdir)+
                                    '" -dp "'+dsopath+'"')<>0  then
    fatalerror(2,"failed to start Mosel instance")
   end-if
   setenv("MOSEL_DSO",env_dsopath)
   wkr.onceonly:=spe.size>0
   wkr.nbtest:=0
  end-if
  ! restore environment of current model
  if spe.size>0 then
   forall(s in spe)
    setenv(s,"")
   defsetenv             ! Restore defaults
  end-if

  ! restart on detach if resquested or dummy test (num=0)
  if tres.opts("restart")="true" or tres.num=0 : wkr.onceonly:=true

  setcontrol(wkr.minst,"lang","en")
  outpath:=string(expandpath(outlog(tres)))
  errpath:=string(expandpath(errlog(tres)))
  if SHOWLOGS and RFMT="" and NBW<=1 then
   outpath:="tee:"+outpath+"&rmt:sysfd:1"
   errpath:="tee:"+errpath+"&rmt:sysfd:2"
  end-if
  setdefstream(wkr.minst,F_INPUT,"null:")
  setdefstream(wkr.minst,F_OUTPUT+F_LINBUF,outpath)
  setdefstream(wkr.minst,F_ERROR+F_LINBUF,errpath)
  if getfstat(wkr.workdir+"/makefile")=0 then
   fcopy("tmp:makefile",wkr.workdir+"/makefile")
  end-if

  wkr.tnum:=tres.num
  wkr.file:=f
  wkr.nbtest+=1
  tres.wnbt:=wkr.nbtest
 end-do
 tres.time:=-gettime
 if MAXWAIT>0 and settimer(tres.wid,MAXWAIT*1000,false)<>tres.wid then
  fatalerror(2,"failed to set timer")
 end-if
 freewks-={tres.wid}
end-procedure

!**************************************
!* Clean up Mosel instance after a run
!**************************************
procedure detachworker(tres:s_test)
 declarations
  lsf:list of text
 end-declarations

 if tres.time<0 then
  tres.time+=gettime
 end-if
 canceltimer(tres.wid)

 with wkr=workers(tres.wid) do
  wkr.tnum:=-1
  wkr.file:=""
  freewks+={tres.wid}
  if wkr.minst.status<>0 or wkr.onceonly then
   disconnect(wkr.minst)
  else
   setparam("ioctrl",true)
    unload(wkr.mdr)
    iost:=getparam("iostatus")
    if iost=0 then
     setdefstream(wkr.minst,"null:","","")
     iost:=getparam("iostatus")
    end-if
   setparam("ioctrl",false)
   if iost<>0 then  ! instance crashed
    disconnect(wkr.minst)
   else
    ! If we have built modules, unload them before cleanup
    findfiles(SYS_NODIR+SYS_NOSORT,lsf,wkr.workdir,"*.dso")
    if lsf.size>0: setcontrol(wkr.minst,"flushdso","")
   end-if
  end-if
 end-do
end-procedure

!***********************************
!* Merge 2 parameter lists
!***********************************
function mergeparms(p1:text,p2:text):text
 if p1="" then
  returned:=p2
 elif p2="" then
  returned:=p1
 else
  returned:=p1
  trim(returned)
  tt:=p2
  trim(tt)
  returned+=text(",")+tt
 end-if
end-function

!********************************************
!* Run an executable on the remote instance
!********************************************
function dorun(tres:s_test,f:text):boolean
 fopen("tmp:dorun.mos",F_OUTPUT)
 writeln(`DOMAKE
model domake
uses 'mmsystem'
parameters
 TODO=""
end-parameters
system(TODO)
exit(getsysstat)
end-model
DOMAKE`)
 fclose(F_OUTPUT)
 if endswith(f,".class") then
  if sysname="windows" then
   todo:=text('java -enableassertions ')+(f-".class")
  else
   todo:=text('java -d')+sysarch+" -enableassertions "+(f-".class")
  end-if
 else
  todo:='.'+DIRSEP+f
 end-if

 with wkr=workers(tres.wid) do
  if safecompile(wkr,"g","rmt:tmp:dorun.mos","tmp:bimfile")<>0 or
     safeload(wkr,"tmp:bimfile") then
   returned:=true
  else
   run(workers(tres.wid).mdr,text("TODO='")+todo+"'")
   tres.status:=TST_RUNNING
  end-if
 end-do
end-function

!***********************************
!* Execute a model on the instance
!***********************************
function execmos(wkr:s_worker,torun:text,parms:text):integer
 if torun<>"" then
  if safecompile(wkr,"g",torun,"tmp:bimfile")<>0 or
     safeload(wkr,"tmp:bimfile") then
   returned:=-1
  else
   run(wkr.mdr,parms)
   waitforend(wkr.mdr,3*60)   ! no more than 3min here
   if waitexpired then
    stop(wkr.mdr)
    waitforend(wkr.mdr,20)    ! additional 20s to cleanup
    if waitexpired then       ! something went wrong: kill instance
     kill(wkr.minst)
     waitforend(wkr.mdr)
    end-if
    returned:=-2
   elif wkr.mdr.status<>0 then
    returned:=-2
   else
    returned:=wkr.mdr.exitcode
   end-if
  end-if
 end-if
end-function

!********************************************
!* Build what has to be built before the run
!********************************************
function dobuild(wkr:s_worker,tobuild:text):boolean
 declarations
  lsb:list of text
 end-declarations

 if tobuild<>"" then
  lsb:=splitlist(tobuild)
  forall(td in lsb) do
   if endswith(td,".bim") then
    if safecompile(wkr,"g",(td-".bim")+".mos",td)<>0 then
     returned:=true
     break
    end-if
   elif domake(wkr,td) then
    returned:=true
    break
   end-if
  end-do
 end-if
end-function

!***************************
!* Get all files to be run
!***************************
function gettotest(path:text,incl:text,excl:text):list of string
 declarations
  f:text
  lsf:list of text
  tincl,texcl:list of string
 end-declarations

 tincl:=getfltlist(incl)
 if tincl.size=0: tincl:=["*"]
 texcl+=getfltlist(excl)+["*.dir"+DIRSEP+"*"]+excludepat

 while (path.size>1 and endswith(path,DIRSEP))
  deltext(path,path.size,path.size)

 if filexists(path) then
  f:=pathsplit(SYS_FNAME,path,path)
  returned:=[string(f)]
 elif endswith(path,".dir") and bittest(getfstat(path), SYS_TYP)=SYS_DIR then
  f:=pathsplit(SYS_FNAME,path,path)
  returned:=[string(f)]
 else
  findfiles(SYS_RECURS+SYS_NODIR,lsf,path,"*.mos|*.c|*.java|*.zip|*.tar|*.tgz|*.tar.gz|*.mcf")
  forall(l in lsf| (or(ff in tincl) pathmatch(l,ff)) and not (or(ff in texcl) pathmatch(l,ff)))
    returned+=[string(l)]
  lsf:=[]
  findfiles(SYS_RECURS+SYS_DIRONLY,lsf,path,"*.dir")
  forall(l in lsf| (or(ff in tincl) pathmatch(l,ff)) and not (or(ff in texcl) pathmatch(l,ff)))
    returned+=[string(l)]
  qsort(SYS_UP,returned)
 end-if
end-function

!***********************************
!* Get an inclusion/exclusion list
!***********************************
function getfltlist(flt:text): list of string
 declarations
  l:text
  repl:string
  lsf:list of text
 end-declarations

 trim(flt)
 if flt<>"" then
  if getchar(flt,1)=getchar("@") then
   if flt="@" then
    fatalerror(1,"Invalid filter specification")
   else
    localsetparam("ioctrl",true)
    fopen(copytext(flt,2,flt.size),F_INPUT)
    if getparam("iostatus")<>0 then
     fatalerror(1,"Filter file not found")
    else
     while(readtextline(l)>0) do
      trim(l)
      fc:=getchar(l,1)
      if fc<>0 and fc<>getchar("#") and fc<>getchar("!"): lsf+=[text(l)]
     end-do
     fclose(F_INPUT)
    end-if
   end-if
  else
   lsf:=splittext(0,flt,",")
  end-if

  repl:=if(sysname="windows","/",'\\')
  dsep:=if(sysname="windows",'\\','/')
  forall(f in lsf) do
   trim(f)
   if f<>"" then
    asproc(regreplace(f,repl,dsep))
    returned+=[string(f)]
   end-if
  end-do
 end-if
end-function

!*********************
!* Clear a directory
!*********************
procedure cleardir(p:text,rmd:boolean)
 declarations
  lsf:list of text
 end-declarations

 ! Firstly remove files only
 removefiles(SYS_RECURS+SYS_NODIR,p,"*")

 if getsysstat<>0 then
  logmsg(MSL_WAR,"Failed to remove files from ",p)
 else
  if sysname="windows" then
   ! Under Windows there may remain dso/exe files still loaded, these will have
   ! been marked for deletion & will be actually deleted once they are unloaded.
   allgone:=false
   forall(i in 0..120) do
    if i>0 then sleep(500); end-if
    lsf:=[]
    findfiles(SYS_RECURS+SYS_NODIR+SYS_NOSORT,lsf,p,"*")
    if getsize(lsf)=0 then allgone:=true; break; end-if
   end-do
   if not allgone then
    logmsg(MSL_WAR,"Unable to remove all files from ",p,", remaining files: ",lsf)
   end-if
  end-if
  ! second round to remove directories
  removefiles(SYS_RECURS,p,"*")
 end-if

 if rmd: removedir(p)
end-procedure

!*************************
!* Copy a directory tree
!*************************
procedure copydir(src:text,dst:string)
 declarations
  lsf:list of text
 end-declarations
 findfiles(SYS_RECURS,lsf,src,"*")
 if lsf.size>0 then
  newtar(0,"tmp:ttar",src,lsf)
  untar("tmp:ttar",dst)
  if getsysstat <> 0 then
   logmsg(MSL_WAR,'Could not copy files from "',src,'" to "',dst,'"!')
  end-if
  fdelete("tmp:ttar")
 end-if
end-procedure

!**************************************
!* Find the "main" file in a directory
!**************************************
function findmain(wkdir:string,totest:text):integer
 declarations
  lsf:list of text
 end-declarations

 totest:=""
 returned:=TFT_UNKNOWN

 findfiles(SYS_NODIR,lsf,wkdir,"main.mos|main.c|Main.java|main.java|main.mcf")
 if lsf.size<>1 then
  lsf:=[]
  findfiles(SYS_NODIR,lsf,wkdir,"*.mos|*.c|*.java|*.mcf")
 end-if

 if lsf.size=1 then
  totest:=lsf.first
  forall(e in [".mos",".c",".java",".mcf"],i as counter)
   if endswith(totest,e) then
    returned:=i-1
    break
   end-if
 end-if
end-function

!******************************************
!* Find the model file of a configuration
!******************************************
function findmodel(wkdir:text,mtt:text):text
 if mtt<>"" then
  if not endswith(mtt,".bim") and not endswith(mtt,".zip") then
   mtt+=".bim"
  end-if
  forall(pfx in bim_dirs) do
   path:=expandpath(pfx+DIRSEP+mtt)
   if filexists(path) then
    if endswith(mtt,".zip") then
     returned:=expandapp(wkdir,path)
    else
     fcopy(path,wkdir)
     returned:=mtt
    end-if
    break
   end-if
  end-do
 end-if
end-function

!***********************************
!* Expand an application zip-file
!***********************************
function expandapp(wkdir:text,path:text):text
 declarations
  lsf:list of text
 end-declarations

 unzip(path,wkdir)
 if getsysstat<>0 then
  logmsg(MSL_WAR,"Failed to extract zip file '",path,"'")
 else
  findfiles(SYS_NODIR,lsf,wkdir,"*.bim")
  if lsf.size=1 then
   returned:=lsf(1)
   reset(lsf)
   findfiles(SYS_NODIR,lsf,wkdir,"model_resources/*")
   forall(f in lsf)
    fcopy(wkdir+DIRSEP+f,wkdir)
  end-if
 end-if
end-function

!***********************************
!* Process tags of a source file
!***********************************
procedure gettags(f:text,opts:array(set of string) of text)
 declarations
  line,val:text
  parm:string
 end-declarations

 delcell(opts)
 fopen(f,F_INPUT)
 while(readtextline(line)>=0) do
  trim(line)
  if startswith(line,CONFLINE) then
   deltext(line,1,CONFLINE.size)
   parm:=splicfgline(line,val)
   if parm in OPTNAMES then
    if val="" then
     delcell(opts(parm))
    elif OPTTYPES(parm)='lst' and opts(parm).size>0 then
     opts(parm)+=' '+val
    elif OPTTYPES(parm)='lsp' and opts(parm).size>0 then
     opts(parm)+=','+val
    elif OPTTYPES(parm)='lns' and opts(parm).size>0 then
     opts(parm)+="\n"+val
    else
     opts(parm):=val
    end-if
   else
    logmsg(MSL_WAR,"   Warning: tag `",if(parm.size>0,text(parm),line),
            "' ignored (file ",pathsplit(SYS_FNAME,f),")")
   end-if
  end-if
 end-do
 fclose(F_INPUT)
end-procedure

!************************************
!* Set default environment variables
!************************************
procedure defsetenv
 setenv("SRCDIR",env_srcdir)
 setenv("DSODIR",env_dsodir)
 setenv("DATADIR",env_datadir)
 setenv("MOSEL_DSO",env_dsopath)   ! For submodels created by worker
 setenv("MOSEL_BIM",env_bimpfx)    ! For submodels created by worker
 setenv("MOSEL_TMP",env_tmpdir)
 setenv("CLASSPATH",env_clspath)
end-procedure

!**********************************
!* Update environment if requested
!**********************************
procedure updenv(env:text,spe:set of string)
 declarations
  mp:array(0..3) of textarea
  lp:list of text
 end-declarations

 lp:=splitlist(env,10)
 forall(e in lp) do
  trim(e)
  if regmatch(e,'^([-a-z0-9]+)\.([A-Za-z0-9_]+) *=(.*)',1,REG_EXTENDED,mp) then
   esys:=copytext(e,mp(1))
   if esys<>sysname and esys<>sysnaarch then
    if endswith(esys,"32") or endswith(esys,"64") then
     deltext(esys,esys.size-1,esys.size)
    end-if
    if string(esys) not in KNOWNSYSNAMES then
     logmsg(MSL_WAR,"Warning: tag `setenv ",e,"' ignored (unknown system name)")
    end-if
    next
   else
    ename:=copytext(e,mp(2))
    eval:=copytext(e,mp(3))
   end-if
  elif regmatch(e,'^([A-Za-z0-9_]+) *=(.*)',1,REG_EXTENDED,mp) then
   ename:=copytext(e,mp(1))
   eval:=copytext(e,mp(2))
  else
   logmsg(MSL_WAR,"Warning: tag `setenv ",e,"' ignored (syntax error)")
   next
  end-if
  spe+={string(ename)}
  setenv(ename,expenv(eval))
 end-do
end-procedure

!***************************************
!* Expand ${} for environment variables
!***************************************
function expenv(ev:text):text
 declarations
  mp:array(0..1) of textarea
 end-declarations

 returned:=ev
 while(regmatch(returned,'\${\([A-Za-z_][A-Za-z0-9_]*\)}',1,0,mp)) do
  eval:=getenv(copytext(returned,mp(1)))
  deltext(returned,mp(0))
  if eval.size>0 then
   inserttext(returned,eval,mp(0).start)
  end-if
 end-do
end-function

!********************************
!* Check whether a file is emty
!********************************
function isnonempty(f:string):boolean
 returned:=filexists(f) and getfsize(f)>0
end-function

!*****************************************************
!* Make sure a path uses '/' for directory separation
!*****************************************************
function mkuxpath(p:string):text
 returned:=p
 asproc(regreplace(returned,'\\','/'))
end-function

!*********************************
!* Generate a label from a path
!*********************************
function mklabpath(p:string):text
 returned:=mkuxpath(p)
 asproc(regreplace(returned,'\.\./',''))
end-function

!**************************************
!* Generate the output file of a test
!**************************************
function outlog(tres:s_test):string
 returned:=OUTDIR+DIRSEP+"out_"+tres.num+".txt"
end-function

!**************************************
!* Generate the error file of a test
!**************************************
function errlog(tres:s_test):string
 returned:=OUTDIR+DIRSEP+"err_"+tres.num+".txt"
end-function

!*****************************************
!* Check whether a test should be skipped
!*****************************************
function toskip(prevstat:integer,tres:s_test):boolean
 declarations
  mp:array(0..3) of textarea
 end-declarations

 with opts=tres.opts do
  if labels_skip.size>0 or labels_only.size<>0 then
   labels:=splitset(opts("labels"))
   if getsize(labels*labels_skip)>0 then
    tres.msg:="excluded by label"
    break
   elif labels_only.size>0 and getsize(labels*labels_only)=0 then
    tres.msg:="missing label"
    break
   end-if
  end-if
  if prevstat=TST_SKIPPED then
   tres.msg:="because of predecessor"
  elif opts("skip")="true" then
   tres.msg:="disabled"
  else
   if opts("skip_host")<>"" then
    lsn:=splitset(opts("skip_host"))
    if syshost in lsn then
     tres.msg:="on this host"
    end-if
   end-if
   if not returned and opts("skip_sys")<>"" then
    lsn:=splitset(opts("skip_sys"))
    if sysname in lsn or sysnaarch in lsn or 
       sysproc in lsn or sysnaproc in lsn then
     tres.msg:="on this system"
    end-if
   end-if
   if not returned and opts("only_host")<>"" then
    lsn:=splitset(opts("only_host"))
    if syshost not in lsn then
     tres.msg:="on this host"
    end-if
   end-if
   if not returned and opts("only_sys")<>"" then
    lsn:=splitset(opts("only_sys"))
    if sysname not in lsn and sysnaarch not in lsn and
       sysproc not in lsn and sysnaproc not in lsn  then
     tres.msg:="on this system"
    end-if
   end-if
   if not returned and opts("required")<>"" then
    forall(p in splittext(opts("required"),","))
     if regmatch(p,' *\([-_.a-zA-Z0-9]*\) *\([<>]\) *\([0-9][0-9.]*\)',1,0,mp) then
      m:=string(copytext(p,mp(1)))
      mv:=copytext(p,mp(3))
      d:=copytext(p,mp(2))
      v:=getpmvers(m)
      if v<0 then
       tres.msg:=text("missing '")+m+"'"
      else
       reset(mp)
       if regmatch(mv,'\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)',1,0,mp) then
        mvn:=parseint(mv,mp(1))*1000000+parseint(mv,mp(2))*1000+parseint(mv,mp(3))
       elif regmatch(mv,'\([0-9]*\)\.\([0-9]*\)',1,0,mp) then
        mvn:=parseint(mv,mp(1))*1000000+parseint(mv,mp(2))*1000
       else
        mvn:=parseint(mv,1)*1000000
       end-if
       if (d=">" and v<mvn) or (d="<" and v>mvn) then
        tres.msg:="incompatible version of '"+m+"' ("+pmvers_txt(m)+d+mv+")"
       end-if
      end-if
     else
      tres.msg:="Malformed 'required' tag '"+p+"' - test ignored"
     end-if
   end-if
  end-if
 end-do

 if tres.msg.size>0 then
  tres.status:=TST_SKIPPED
  returned:=true
 end-if
end-function

!*******************************************
!* Split a line of the form name |:|= value
!*******************************************
function splicfgline(line:text,val:text):string
 declarations
  mp:array(0..2) of textarea
  dv:real
 end-declarations
 trim(line)
 if regmatch(line,'^\([a-zA-Z0-9_]*\) *[ :=] *\(.*\)',1,0,mp) then
  returned:=string(copytext(line,mp(1)))
  val:=copytext(line,mp(2))
  trim(val)
  if val.size>0 and returned in OPTNAMES then
   case OPTTYPES(returned) of
    'int': do
	 dv:=parseint(val,1)
	 if getparam("sys_endparse")<>val.size+1 or getsysstat<>0 then
	  returned:=""
	 end-if
	end-do
    'boo': do
	 val:=tolower(val)
	 if val<>"true" and val<>"false" then
	  returned:=""
	 end-if
	end-do
    'dbl': do
	 dv:=parsereal(val,1)
	 if getparam("sys_endparse")<>val.size+1 or getsysstat<>0 then
	  returned:=""
	 end-if
	end-do
    ! else: text
   end-case
  end-if
 ! Special case of a Boolean tag (only the name of the tag for 'true')
 elif regmatch(line,'^\([a-zA-Z0-9_]*\)$',1,0,mp) then
  returned:=string(copytext(line,mp(1)))
  if returned in OPTNAMES and OPTTYPES(returned)='boo' then
   val:="true"
  else
   returned:=""
   val:=""
  end-if
 end-if
end-function

!****************************************************
!* Check whether a file exists and is a regular file
!****************************************************
function filexists(f:text):boolean
 fstat:=getfstat(f)
 if fstat<>0 then
  returned:=bittest(fstat,SYS_TYP)=SYS_REG and bittest(fstat,SYS_MOD)>=SYS_READ
 ! else: returned:=false
 end-if
end-function

!****************************************************
!* Check whether a file exists and is a directory
!****************************************************
function direxists(f:text):boolean
 fstat:=getfstat(f)
 if fstat<>0 then
  returned:=bittest(fstat,SYS_TYP)=SYS_DIR and bittest(fstat,SYS_MOD)>=SYS_READ
 ! else: returned:=false
 end-if
end-function

!************************************
!* Look for a pattern in a log file
!************************************
function findpattern(rpat:text,f:text,rtmsg:text):boolean
 declarations
  mp:array(0..0) of textarea
  line:text
  lp:list of text
  cnt:integer
 end-declarations

 if rpat<>"" then
  lp:=splitlist(rpat,10)
  if not filexists(f) then
   returned:=true
   rtmsg:=formattext("#1: %s",lp.first)
  else
   fopen(f,F_INPUT)
   returned:=true
   cnt:=1
   p:=string(lp.first)
   while(readtextline(line)>=0) do
    if regmatch(line,p,1,REG_EXTENDED,mp) then
     cuthead(lp,1)
     if lp.size=0 then
      returned:=false
      break
     else
      p:=string(lp.first)
      cnt+=1
     end-if
    end-if
   end-do
   fclose(F_INPUT)
   rtmsg:=if(returned,formattext("#%d: %s",cnt,lp.first),text(""))
  end-if
 else
  reset(rtmsg)
 end-if
end-function

!****************************************************
!* Split a list of names (with choice of separator)
!****************************************************
function splitlist(t:text,sc:integer):list of text
 declarations
  pctx:parsectx
 end-declarations

 pctx.sepchar:=sc
 if sc=10 then  ! no quoting when splitting full lines
  pctx.qtype:=-1
 end-if
 while(nextfield(t,pctx)) do
  returned+=[parsetext(t,pctx)]
 end-do
end-function

!*************************
!* Split a list of names
!*************************
function splitlist(t:text):list of text
 returned:=splitlist(t,32)
end-function

!************************
!* Split a set of names
!************************
function splitset(t:text):set of string
 declarations
  pctx:parsectx
 end-declarations

 pctx.sepchar:=32  ! ' '
 while(nextfield(t,pctx)) do
  returned+={string(parsetext(t,pctx))}
 end-do
end-function

!******************
!* Save log files
!******************
procedure savelogs(tres:s_test)
 declarations
  lfname,ff: text
 end-declarations

 outfile:=outlog(tres)
 errfile:=errlog(tres)
 ff:=tres.label
 if LOGDIR="" then
  if repfile<>'-' then
   fopen(repfile,F_OUTPUT+F_APPEND)
   writeln("+"*78)
   writeln(if(ff.size<77,"="*(77-ff.size),text("=="))," ",ff)
   if isnonempty(outfile) then
    writeln("==== ","output"," ====")
   end-if
   fclose(F_OUTPUT)
   fcopy(outfile,F_SILENT,repfile,F_APPEND)
   if isnonempty(errfile) then
    fopen(repfile,F_OUTPUT+F_APPEND)
    writeln("==== ","error"," ====")
    fclose(F_OUTPUT)
    fcopy(errfile,F_SILENT,repfile,F_APPEND)
   end-if
  end-if
 else
  asproc(regreplace(ff,'([/:\\])',"_",1,REG_EXTENDED))
  if isnonempty(outfile) then
    if repdate<>"" then
      lfname:="out"+repdate+".txt"
    else
      lfname:="out.txt"
    end-if
    fcopy(outfile,LOGDIR+"/"+ff+"_"+lfname)
  end-if
  if isnonempty(errfile) then
    if repdate<>"" then
      lfname:="err"+repdate+".txt"
    else
      lfname:="err.txt"
    end-if
    fcopy(errfile,LOGDIR+"/"+ff+"_"+lfname)
  end-if
 end-if
end-procedure

!******************
!* Display log files
!******************
procedure showlogs(tres:s_test)
 outfile:=outlog(tres)
 errfile:=errlog(tres)
 if isnonempty(outfile) then
  fflush
  fcopy(outfile,F_TEXT,"sysfd:1",F_APPEND)
 end-if
 if isnonempty(errfile) then
  fcopy(errfile,F_TEXT,"sysfd:2",F_APPEND)
 end-if
end-procedure

!**********************************
!* Prepare system dependent stuff
!**********************************
procedure setsysdep
 sysname:=string(tolower(getsysinfo(SYS_NAME)))
 sysarch:=integer(getsysinfo(SYS_ARCH))
 sysproc:=string(tolower(getsysinfo(SYS_PROC)))
 sysnaarch:=sysname+sysarch
 sysnaproc:=sysname+"-"+sysproc
 syshost:=getsysinfo(SYS_NODE)

 asproc(getpmvers('mosel'))
 pmvers(""):=-1

 if sysname="windows" and HAVENMAKE then
   ! use nmake if it is available
   fopen("null:",F_OUTPUT)
   fopen("null:",F_ERROR)
   system("nmake -nologo -?")
   fclose(F_ERROR)
   fclose(F_OUTPUT)
   usenmake := getsysstat = 0
   if not usenmake then
     logmsg(MSL_WAR,"WARNING: Could not find 'nmake'! Using 'make'.")
   end-if
 end-if

 if REPDATED then
  if REPDATEFMT<>"": localsetparam("datetimefmt",REPDATEFMT)
  repdate:=text("_")+text(datetime(SYS_NOW))
 end-if
 if REPFILE<>"" then
  repfile:=REPFILE
 else
  repfile:=BASEREP+repdate+".txt"
 end-if
 if REPRESET then
  fdelete(repfile)
 end-if
 fopen("tmp:makefile",F_OUTPUT)
 writeln(".SUFFIXES: .bim .mos .dso .java .class")
 if sysname="windows" then
  if sysarch=32 then
   writeln('CFLAGS=-nologo -Zi -MD -I"$(XPRESSDIR)\include"')
  else
   writeln('CFLAGS=-nologo -Zi -MD -GS- -I"$(XPRESSDIR)\include"')
  end-if
  writeln(`WIN32
.c.exe:
	$(CC) $(CFLAGS) $< -link -libpath:"$(XPRESSDIR)\lib" xprm_mc.lib xprm_rt.lib xprd.lib bindrvMD.lib
.c.dso:
	$(CC) $(CFLAGS) -LD $< -Fe$*.dso
.mos.bim:
	mosel compile -g $*.mos
.java.class:
	javac $*.java
WIN32`)
 else				! 32bit Unix
  if sysarch=32 then
   case sysname of
    "linux":writeln(`LIN32
CFLAGS=-m32 -D_REENTRANT -I$(XPRESSDIR)/include
MAKEDSO=$(CC) -m32 -shared
LIN32`)
    "sunos":writeln(`SOL32
CFLAGS=-D_REENTRANT -Kpic -I$(XPRESSDIR)/include
LDFLAGS=-lrt -lsocket -lnsl -lm
MAKEDSO=$(LD) -G
SOL32`)
    "hp-ux":writeln(`HP32
CFLAGS=+Z +DAportable -D_POSIX_C_SOURCE=199506L -I$(XPRESSDIR)/include
LDFLAGS=-lm -Wl,+s
MAKEDSO=$(LD) -b +s
HP32`)
    "aix":writeln(`AIX32
CFLAGS=-q32 -D_THREAD_SAFE -I$(XPRESSDIR)/include
LDFLAGS=-lm -brtl
MAKEDSO=$(CC) -G -q32 -brtl
AIX32`)
   end-case
  else				! 64bit Unix
   case sysname of
    "linux":
	if sysproc="aarch64" then
         writeln(`AARCH64
CFLAGS=-fpic -D_REENTRANT -I$(XPRESSDIR)/include
LDFLAGS=
MAKEDSO=$(CC) -shared
AARCH64`)
	else
         writeln(`LIN64
CFLAGS=-m64 -fpic -D_REENTRANT -I$(XPRESSDIR)/include
LDFLAGS=-fopenmp
MAKEDSO=$(CC) -m64 -shared
LIN64`)
	end-if
    "sunos":writeln(`SOL64
CFLAGS=-m64 -D_REENTRANT -Kpic -I$(XPRESSDIR)/include
LDFLAGS=-lrt -lsocket -lnsl -lm
MAKEDSO=$(LD) -G
SOL64`)
    "hp-ux":writeln(`HP64
CFLAGS=+Z +DD64 -D_POSIX_C_SOURCE=199506L -I$(XPRESSDIR)/include
LDFLAGS=-lm -Wl,+s
MAKEDSO=$(LD) -b +s
HP64`)
    "aix":writeln(`AIX64
CFLAGS=-q64 -D_THREAD_SAFE -I$(XPRESSDIR)/include
LDFLAGS=-lm -brtl
MAKEDSO=$(CC) -G -q64 -brtl
AIX64`)
    "darwin":writeln(`MAC
CFLAGS=-m64 -I$(XPRESSDIR)/include
MAKEDSO=$(CC) -m64 -dynamiclib
MAC`)
   end-case
  end-if
  writeln(`UNX
.c:
	$(CC) $(CFLAGS) $(LDFLAGS) $< -L$(XPRESSDIR)/lib -lxprm_mc -lxprm_rt -lxprd -lbindrv -lpthread -o $*
.c.dso:
	$(CC) -c $(CFLAGS) $<
	$(MAKEDSO) $*.o -o $*.dso
.mos.bim:
	mosel compile -g $*.mos
.java.class:
	javac $*.java
UNX`)
  end-if
  fclose(F_OUTPUT)
end-procedure

!************************************
!* Load a model on 'minst' "safely"
!************************************
function safeload(wkr:s_worker,bf:text):boolean
 localsetparam("ioctrl",true)
 load(wkr.minst,wkr.mdr,bf)
 returned:= getparam("iostatus")<>0
end-function

!***************************************
!* Compile a model on 'minst' "safely"
!***************************************
function safecompile(wkr:s_worker,opts:string,src:text,dst:text):integer
 localsetparam("ioctrl",true)
 returned:=compile(wkr.minst,opts,src,dst)
 asproc(getparam("iostatus"))
end-function

!***************************
!* Start an xprmsrv server
!***************************
procedure startxsrv
 declarations
  inst:Mosel
 end-declarations

 if PIDFILE<>"" then
  fopen("null:",F_ERROR)
  c:=connect(inst,"127.0.0.1")
  fclose(F_ERROR)
  if c=0 then
   disconnect(inst)
   logmsg(MSL_WAR,"Warning: using an existing xprmsrv server - remote tests may fail")
  elif system_log("xprmsrv",'-k',expandpath(WKDIR+"/xprmsrv.key"),'-key','new') then
   fatalerror(2,"Failed to generate key file")
  else
   makedir(WKDIR+"/xprmsrv")
   fopen(WKDIR+"/xprmsrv.conf",F_OUTPUT)
   if XSRVLOG<>'' then
    writeln("LOGFILE=",expandpath(XSRVLOG))
    writeln("VERBOSITY=2")
   end-if
   writeln("XPRMSRV_ACCESS=127.0.0.1 ",getsysinfo(SYS_NODE))
   writeln("KEYFILE=",expandpath(WKDIR+"/xprmsrv.key"))
   writeln("MAXAUTHTIME=5")
   writeln("[xpress]")
   if sysname="windows" then
    writeln('MOSEL_CMD=${XPRESSDIR}\bin\mosel.exe -r -d tmp:')
   else
    writeln("MOSEL_CMD=${XPRESSDIR}/bin/mosel -r -d tmp:")
   end-if
   writeln("MOSEL_CWD=",expandpath(WKDIR+"/xprmsrv"))
   writeln("MOSEL_TMP=",env_tmpdir)
   fclose(F_OUTPUT)
   if system_log("xprmsrv",'-tm','1200','-d','-pf',PIDFILE,expandpath(WKDIR+"/xprmsrv.conf")) then
    fatalerror(2,"Failed to start xprmsrv server")
   else
    logmsg(MSL_INF,"xprmsrv server started")
   end-if
  end-if
 end-if
end-procedure

!***************************
!* Stop the xprmsrv server
!***************************
procedure stopxsrv
 if PIDFILE<>"" and filexists(PIDFILE) then
  fcopy(PIDFILE,"text:tfile")
  fdelete(PIDFILE)
  pid:=tfile ! 'tfile' is used by system_log
  trim(pid)
  cmdkill:=if(sysname="windows","tskill","kill")
  if system_log(cmdkill,pid) then
   logmsg(MSL_WAR,"Warning: failed to kill xprmsrv server (pid:",pid,")")
  else
   logmsg(MSL_INF,"xprmsrv server stopped")
  end-if
 end-if
end-procedure

!*****************************************
!* Execute 'make' on the remote instance
!*****************************************
function domake(wkr:s_worker,f:text):boolean
 fopen("tmp:domake.mos",F_OUTPUT)
 writeln(`DOMAKE
model domake
uses 'mmsystem'
parameters
 TODO=""
end-parameters
DOMAKE`)

 if usenmake then
  writeln('system("nmake -nologo "+TODO)')
 else
  writeln('system("make "+TODO)')
 end-if

 writeln(`DOMAKE
exit(getsysstat)
end-model
DOMAKE`)
 fclose(F_OUTPUT)
 returned:=execmos(wkr,"rmt:tmp:domake.mos",text("TODO=")+f)<>0
end-function

!*************************************************
!* Retrieve the version of a pkg/module or Mosel
!*************************************************
function getpmvers(p:string):integer
 declarations
  line:text
  mp:dynamic array(0..3) of textarea
 end-declarations
 if not exists(pmvers(p)) then
  fopen("null:",F_ERROR) ! in case component cannot be found
  fopen("tmp:vers",F_OUTPUT)
  if p="mosel" then
   system('mosel','exam','-l','en','-dp',env_dsopath,'-H')
  else
   system('mosel','exam','-l','en','-dp',env_dsopath,'-H',p)
  end-if
  fclose(F_OUTPUT)
  fclose(F_ERROR)
  fopen("tmp:vers",F_INPUT)
  if readtextline(line)>10 and regmatch(line,'^[a-zA-Z]* .* version \([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)',1,0,mp) then
   pmvers(p):=parseint(line,mp(1))*1000000+parseint(line,mp(2))*1000+parseint(line,mp(3))
   pmvers_txt(p):=copytext(line,mp(1).start,mp(3).succ-1)
   if findtext(p,".",1)=0 then
    if startswith(line,"Package") then
     pmvers(p+".bim"):=pmvers(p)
    elif startswith(line,"Module") then
     pmvers(p+".dso"):=pmvers(p)
    end-if
   end-if
  else
   pmvers(p):=-1
  end-if
  fclose(F_INPUT)
 end-if
 returned:=pmvers(p)
end-function

!*************************************
!* Convert a log file to a text
!*************************************
function logfile2text(f:string):text
 fcopy(f,"text:tfile")
 returned:=tfile
 reset(tfile)
 if MAXLOGLEN>0 and returned.size>MAXLOGLEN then
  sp:=findtext(returned,"\n",returned.size-MAXLOGLEN)
  if sp>0 and sp+1<returned.size then
   sp+=1
  else
   sp:=returned.size-MAXLOGLEN
  end-if
  deltext(returned,1,sp)
  returned:="...\n"+returned
 end-if
end-function

!**********************************
!* Call 'system' and save output
!**********************************
function system_log(cmd:string,args:...):boolean
 fopen("tmp:sys_out.log",F_OUTPUT)
 fopen("tmp:sys_err.log",F_ERROR)
 system(cmd,args)
 returned:=getsysstat<>0
 fclose(F_ERROR)
 fclose(F_OUTPUT)
 if getfsize("tmp:sys_out.log")>0 then
  tolog:=logfile2text("tmp:sys_out.log")
  if getchar(tolog,tolog.size)=getchar("\n"):
                                          deltext(tolog,tolog.size,tolog.size)
  logmsg(MSL_INF,tolog)
 end-if
 if getfsize("tmp:sys_err.log")>0 then
  tolog:=logfile2text("tmp:sys_err.log")
  if getchar(tolog,tolog.size)=getchar("\n"):
                                          deltext(tolog,tolog.size,tolog.size)
  logmsg(MSL_ERR,tolog)
 end-if
 fdelete("tmp:sys_out.log")
 fdelete("tmp:sys_err.log")
end-function

!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
declarations
 function checkpackage(wkr:s_worker,scs:array(sf:set of string) of s_srcfile,pkg:text,lsf:list of string,ft:text):boolean
 procedure compcov(sfs:array(sf:set of string) of s_srcfile)
 procedure genreport(srcf:s_srcfile,src:string,covdir:text)
 procedure genlcovinfo(scs:array(sf:set of string) of s_srcfile,covdir:text)
 procedure gencoberturaxml(scs:array(sf:set of string) of s_srcfile,covdir:text)
 function addsrcfile(workdir:string,scs:array(string) of s_srcfile,src:string,appzip:text):boolean
 function countlines(f:text):integer
 function findsrc(workdir:string,f:string,appzip:text):text
 function lndx2file(l:integer):integer
 function lndx2line(l:integer):integer
end-declarations

!****************************************************
! Generate a list of directories from parameter
!****************************************************
function build_lstdir(srcpath:string):list of text
 returned:=splittext(srcpath,PATHSEP)
 if returned.size>0 then
  forall(p in returned) do
   p:=expandpath(p)
  end-do
 else
  returned:=[expandpath(".")]
 end-if
end-function

!****************************************************
! Generate srcfiles from parameter
!****************************************************
procedure build_srcfiles(sfs:array(sf:set of string) of s_srcfile,pkgs:list of text)
 declarations
  allpkgs:set of constant text
  lsf:list of string
  ft:text
  dummy:s_test
 end-declarations

 ! use a dummy test context running on worker 1 for this operation
 dummy.num:=0
 dummy.wid:=1
 attachworker("dummy",dummy)
 forall(p in pkgs) do
  trim(p)
  if p<>"" and p not in allpkgs and checkpackage(workers(1),sfs,p,lsf,ft) then
   logmsg(MSL_INF," + ",ft," '",p,"' registered ",lsf)
   allpkgs+={p}
  end-if
 end-do
 cleardir(workers(1).workdir,false)
 detachworker(dummy)

 if sf.size=0 then
  fatalerror(3,"No package for coverage")
 end-if
end-procedure

!****************************************************
!* Save coverage data from mdr on minst
!****************************************************
procedure savecovres(wkr:s_worker,sfs:array(sf:set of string) of s_srcfile)
 declarations
  Rlines:range
  lines:array(Rlines) of integer
  iters:array(Rlines) of integer
  Rfiles:range
  files:array(Rfiles) of string
  Rstarts:range
  starts:array(Rstarts) of integer
 end-declarations

 localsetparam("ioctrl",true)
 nid:=getid(wkr.minst)
 initialisations from "bin:rmt:["+nid+"]mcmd:covres@1"
  Rlines lines iters
  Rfiles files
  Rstarts starts
 end-initialisations
 if getparam("iostatus")=0 then
  forall(f in 0..(getlast(Rstarts)-1)|files(f) in sf)
   with srcf=sfs(files(f)) do
    forall(i in starts(f)..(starts(f+1)-1),l=lines(i))
     if l in srcf.rlines and srcf.lincov(l)>=0 then
      srcf.lincov(l)+=iters(i)
     end-if
   end-do
 end-if
end-procedure

!****************************************************
!* Compute and report coverage statistics
!****************************************************
procedure reportcov(sfs:array(sf:set of string) of s_srcfile,covdir:text,mode:integer)
 compcov(sfs)
 localsetparam("realfmt","%.1f")
 logmsg(MSL_INF,"\nGlobal coverage statistics:")
 snbl:=sum(s in sf) sfs(s).nbl
 snblh:=sum(s in sf) sfs(s).nblh
 snbf:=sum(s in sf) sfs(s).nbf
 snbfh:=sum(s in sf) sfs(s).nbfh
 logmsg(MSL_INF,"  lines:    ",snblh*100/snbl,"% (",snblh,"/",snbl,")")
 if snbf>0 then
  logmsg(MSL_INF,"  routines: ",snbfh*100/snbf,"% (",snbfh,"/",snbf,")")
 end-if

 if mode<>0 then
  makedir(covdir)
  logmsg(MSL_INF,"Saving reports in '",covdir,"':")
  if bittest(mode,1)=1: forall(s in sf) genreport(sfs(s),s,covdir)
  if bittest(mode,2)=2: genlcovinfo(sfs,covdir)
  if bittest(mode,4)=4: gencoberturaxml(sfs,covdir)
 end-if
end-procedure

!****************************************************
! Load a model/package and extract source information
!****************************************************
function checkpackage(wkr:s_worker,sfs:array(sf:set of string) of s_srcfile,pkg:text,lsf:list of string,ft:text):boolean
 declarations
  appzip:text
  path:text
  nbs:integer
  newfiles,oldfiles:set of string

  Rfiles: range
  files:  array(Rfiles) of string
  Rlines: range
  lines:  array(Rlines) of integer

  Rsign: range
  sign:  array(Rsign) of text
  lndx:  array(Rsign) of integer
  name:  array(Rsign) of text

  dummy:s_test
 end-declarations

 reset(lsf)
 ft:="Package"
 nid:=getid(wkr.minst)
 forall(pfx in bim_dirs) do
  if endswith(pkg,".zip") then
   path:=expandpath(pfx+DIRSEP+pkg)
   appzip:=path
  else
   path:=expandpath(pfx+DIRSEP+pkg+".bim")
   appzip:=""
  end-if
  if filexists(path) then
   break
  else
   path:=""
  end-if
 end-do
 if path.size>0 then
  localsetparam("ioctrl",true)
  if appzip<>"" then
   cleardir(wkr.workdir,false)
   bimfile:=expandpath(wkr.workdir+DIRSEP+expandapp(wkr.workdir,path))
   load(wkr.minst,wkr.mdr,bimfile,"l","","","")
  else
   load(wkr.minst,wkr.mdr,path,"l","","","")
  end-if
  if getparam("iostatus")=0 then
   if findtext(getmodprop(wkr.mdr,PROP_SYSCOM),"PKG,",1)<1 then
    ft:=if(appzip="","Model","Application")
   end-if
   initialisations from "bin:rmt:["+nid+"]mcmd:dbglndx@1"
    Rfiles files
    Rlines lines
   end-initialisations
   if getparam("iostatus")=0 and Rfiles.size>0 and 
      findtext(getmodprop(wkr.mdr,PROP_SYSCOM),",trace,",1)>0 then
    oldfiles:=sf
    forall(j in Rfiles)
     if endswith(files(j),".mos") and addsrcfile(wkr.workdir,sfs,files(j),appzip) then
      lsf+=[files(j)]
      nbs+=1
     end-if

    if nbs<1 then
     logmsg(MSL_ERR," I could not find any valid source file for '",pkg,"'!!!")
    else
     newfiles:=sf-oldfiles
     ! locate effective statements
     forall(i in Rlines,f=lndx2file(lines(i))| files(f) in newfiles)
      with s=sfs(files(f)),l=lndx2line(lines(i)) do
       if l in s.rlines and s.lincov(l)<0 then
        s.lincov(l):=0
	s.nbl+=1
       end-if
      end-do
    
     ! record subroutines names & location
     fopen("null:",F_ERROR) ! may fail if there is no subroutine
     initialisations from "bin:rmt:["+nid+"]mcmd:dbgflndx@1"
      Rsign sign lndx name
     end-initialisations
     fclose(F_ERROR)
     if getparam("iostatus")=0 and Rsign.size>0 then
      forall(i in Rsign, ld=lndx(i), f=lndx2file(lines(ld))|files(f) in newfiles)
       with s=sfs(files(f)),l=lndx2line(lines(ld)) do
        if l in s.rlines then
         s.nbf+=1
         if sign(i)<>"" then
          s.fctnames(s.nbf):=string(name(i)+"("+sign(i)+")")
         else
          s.fctnames(s.nbf):=string(name(i))
         end-if
         s.fctstart(s.nbf):=l
        end-if
       end-do
     end-if
     returned:=true
    end-if
   else
    logmsg(MSL_WAR," No tracing information found in '",pkg,"'!!!")
   end-if
  else
   ! display instance errors
   if not SHOWLOGS or NBW>1: fcopy(errlog(dummy),"")
   logmsg(MSL_ERR," Failed to load '",path,"'!!!")
  end-if
 else
  logmsg(MSL_ERR," Package '",pkg,"' not found!!!")
 end-if
end-function

!****************************************************
!* Compute coverage statistics summary
!****************************************************
procedure compcov(sfs:array(sf:set of string) of s_srcfile)
  forall(s in sf,srcf=sfs(s)) do
   srcf.nblh:=0
   forall(i in srcf.rlines)
    if srcf.lincov(i)>0 then srcf.nblh+=1; end-if
   srcf.nbfh:=0
   forall(f in srcf.fctstart.index(1),lc=srcf.lincov(srcf.fctstart(f)))
    if lc>0 then srcf.nbfh+=1; end-if
  end-do
end-procedure

!****************************************************
!* Generate a report for a source file
!****************************************************
procedure genreport(srcf:s_srcfile,src:string,covdir:text)
 declarations
  crepfile:text
  l:text
  spc=" "*7
  tsrc:text
 end-declarations

 tsrc:=src
 asproc(regreplace(tsrc,"/","_"))
 asproc(regreplace(tsrc,'\\',"_"))
 asproc(regreplace(tsrc,':',"_"))
 asproc(regreplace(tsrc,';',"_"))
 tsrc+=".cov"
 localsetparam("ioctrl",true)
 crepfile:=covdir+DIRSEP+tsrc
 fopen(crepfile,F_OUTPUT)
 if getparam("iostatus")<>0 then
  logmsg(MSL_ERR," I cannot create the report file '",crepfile,"'!!!")
 else
  fopen(srcf.path,F_INPUT)
  if getparam("iostatus")<>0 then
   logmsg(MSL_ERR," I cannot find source file '",src,"'!!!")
  else
   if srcf.nbf>0 then
    logmsg(MSL_INF," + '",tsrc+"' (l:",srcf.nblh*100/srcf.nbl,
 				        "%,",srcf.nblh,"/",srcf.nbl,
					" r:",srcf.nbfh*100/srcf.nbf,
 				        "%,",srcf.nbfh,"/",srcf.nbf,")")
   else
    logmsg(MSL_INF," + '",tsrc+"' (l:",srcf.nblh*100/srcf.nbl,
 				        "%,",srcf.nblh,"/",srcf.nbl,")")
   end-if
   forall(i in srcf.rlines)
    if readtextline(l)>0 then
     if srcf.lincov(i)>=0 then
      write(textfmt(srcf.lincov(i),4),"   ",l)
     else
      write(spc,l)
     end-if
    else
     break
    end-if
   localsetparam("realfmt","%.1f")
   writeln("\nCoverage: ")
   writeln("  lines:    ",srcf.nblh*100/srcf.nbl,"% (",srcf.nblh,"/",srcf.nbl,")")
   if srcf.nbf>0 then
    writeln("  routines: ",srcf.nbfh*100/srcf.nbf,"% (",srcf.nbfh,"/",srcf.nbf,")")
   end-if
   fclose(F_INPUT)
  end-if
  fclose(F_OUTPUT)
 end-if
end-procedure

!**********************************************
!* Generate the report as a cobertura XML file
!**********************************************
procedure gencoberturaxml(sfs:array(sf:set of string) of s_srcfile,covdir:text)
 declarations
  cob: xmldoc
  crepfile:text
  appdir:text
  nc,np,ncl,ncls,nls,nl,nms:integer
  tlh,tl: integer
 end-declarations

 localsetparam("ioctrl",true)
 crepfile:=covdir+DIRSEP+"moseltest.xml"
 logmsg(MSL_INF," + 'moseltest.xml'")
 n:=addnode(cob,0,XML_LASTCHILD,XML_DATA,"<!DOCTYPE coverage SYSTEM 'http://cobertura.sourceforge.net/xml/coverage-04.dtd'>")
 nc:=addnode(cob,0,XML_LASTCHILD,XML_ELT,"coverage")
 n:=addnode(cob,nc,XML_LASTCHILD,XML_ELT,"packages")
 np:=addnode(cob,n,XML_LASTCHILD,XML_ELT,"package")
 setattr(cob,np,"name","moseltest")
 setattr(cob,np,"complexity",0)
 ncls:=addnode(cob,np,XML_LASTCHILD,XML_ELT,"classes")
 forall(s in sf,srcf=sfs(s)) do
  ncl:=addnode(cob,ncls,XML_LASTCHILD,XML_ELT,"class")
  if startswith(srcf.path,"zlib.zip:") then
   if appdir="" then
    appdir:=expandpath(covdir+DIRSEP+"appsrc")
    makedir(appdir)
    appdir+=DIRSEP
   end-if
   fname:=appdir+pathsplit(SYS_FNAME,s)
   fcopy(srcf.path,fname)
   setattr(cob,ncl,"name",fname)
   setattr(cob,ncl,"filename",fname)
  else
   setattr(cob,ncl,"name",srcf.path)
   setattr(cob,ncl,"filename",srcf.path)
  end-if
  setattr(cob,ncl,"line-rate",formattext("%j",if(srcf.nbl>0,srcf.nblh/srcf.nbl,0)))
  setattr(cob,ncl,"branch-rate",0)
  setattr(cob,ncl,"complexity",0)
  tlh+=srcf.nblh
  tl+=srcf.nbl
  nms:=addnode(cob,ncl,XML_LASTCHILD,XML_ELT,"methods")
  forall(f in srcf.fctstart.index(1),lc=srcf.lincov(srcf.fctstart(f))) do
   nm:=addnode(cob,nms,XML_LASTCHILD,XML_ELT,"method")
   setattr(cob,nm,"name",srcf.fctnames(f))
   setattr(cob,nm,"signature",srcf.fctnames(f))
   setattr(cob,nm,"line-rate",1)
   setattr(cob,nm,"branch-rate",1)
   n:=addnode(cob,nm,XML_LASTCHILD,XML_ELT,"lines")
   n:=addnode(cob,n,XML_LASTCHILD,XML_ELT,"line")
   setattr(cob,n,"hits",lc)
   setattr(cob,n,"number",srcf.fctstart(f))
   setattr(cob,n,"branch","false")
  end-do
  nls:=addnode(cob,ncl,XML_LASTCHILD,XML_ELT,"lines")
  forall(i in srcf.rlines,lc=srcf.lincov(i)|lc>=0,nbl as counter) do
   nl:=addnode(cob,nls,XML_LASTCHILD,XML_ELT,"line")
   setattr(cob,nl,"branch","false")
   setattr(cob,nl,"hits",lc)
   setattr(cob,nl,"number",i)
  end-do   
 end-do
 setattr(cob,np,"line-rate",formattext("%j",if(tl>0,tlh/tl,0)))
 setattr(cob,np,"branch-rate",0)
 setattr(cob,nc,"line-rate",formattext("%j",if(tl>0,tlh/tl,0)))
 setattr(cob,nc,"lines-covered",tlh)
 setattr(cob,nc,"lines-valid",tl)
 setattr(cob,nc,"branch-rate",0)
 setattr(cob,nc,"branch-covered",0)
 setattr(cob,nc,"branch-valid",0)
 setattr(cob,nc,"complexity",0)
 setattr(cob,nc,"version","2.0.0")
 setattr(cob,nc,"timestamp",floor(getasnumber(datetime(SYS_NOW))))
 save(cob,crepfile)
 if getparam("iostatus")<>0: logmsg(MSL_ERR," I cannot create the report file '",crepfile,"'!!!")
end-procedure

!****************************************************
!* Generate the report as an lcov info file
!****************************************************
procedure genlcovinfo(sfs:array(sf:set of string) of s_srcfile,covdir:text)
 declarations
  crepfile:text
  appdir:text
 end-declarations

 localsetparam("ioctrl",true)
 crepfile:=covdir+DIRSEP+"moseltest.info"
 fopen(text("enc:sys+unix,")+crepfile,F_OUTPUT)
 if getparam("iostatus")<>0 then
  logmsg(MSL_ERR," I cannot create the report file '",crepfile,"'!!!")
 else
  logmsg(MSL_INF," + 'moseltest.info'")
  writeln("TN:moseltest")
  forall(s in sf,srcf=sfs(s)) do
   if startswith(srcf.path,"zlib.zip:") then
    if appdir="" then
     appdir:=expandpath(covdir+DIRSEP+"appsrc")
     makedir(appdir)
     appdir+=DIRSEP
    end-if
    fname:=appdir+pathsplit(SYS_FNAME,s)
    fcopy(srcf.path,fname)
    writeln("SF:",fname)
   else
    writeln("SF:",srcf.path)
   end-if
   forall(f in srcf.fctstart.index(1))
    writeln("FN:",srcf.fctstart(f),",",srcf.fctnames(f))
   forall(f in srcf.fctstart.index(1),lc=srcf.lincov(srcf.fctstart(f))) do
    writeln("FNDA:",lc,",",srcf.fctnames(f))
   end-do
   writeln("FNF:",srcf.nbf)
   writeln("FNH:",srcf.nbfh)

   forall(i in srcf.rlines,lc=srcf.lincov(i)|lc>=0,nbl as counter) do
    writeln("DA:",i,",",lc)
   end-do
   writeln("LH:",srcf.nblh)
   writeln("LF:",srcf.nbl)
   writeln("end_of_record")
  end-do
  fclose(F_OUTPUT)
  logmsg(MSL_INF," To produce a HTML report use the following comand:")
  logmsg(MSL_INF,"  genhtml -o ",covdir,DIRSEP,"html ",covdir,DIRSEP,"moseltest.info")
 end-if
end-procedure

!****************************************************
!* Add a new file to the array of source files
!****************************************************
function addsrcfile(workdir:string,sfs:array(sf:set of string) of s_srcfile,src:string,appzip:text):boolean
 declarations
  path:text
  src2:text
 end-declarations

 if src in sf then
  returned:=true
 else
  path:=findsrc(workdir,src,appzip)
  if path="" then
   src2:=pathsplit(SYS_FNAME,src)
   if src2<>src then
    path:=findsrc(workdir,string(src2),appzip)
   end-if
  end-if
  if path="" then
   logmsg(MSL_ERR," Cannot find source file '",src,"'!!!")
  else
   nbl:=countlines(path)
   if nbl<1 then
    logmsg(MSL_WAR," Source file '",src,"' is empty!!!")
   else
    create(sfs(src))
    with srcf=sfs(src) do
     srcf.path:=path
     srcf.rlines:=1..nbl
     finalise(srcf.rlines)
     srcf.lincov(1):=-1
     srcf.lincov(nbl):=-1
     finalise(srcf.lincov.index(1))
     forall(i in srcf.rlines)
      srcf.lincov(i):=-1
    end-do
    returned:=true
   end-if
  end-if
 end-if
end-function

!****************************************************
!* Try to find a source file
!****************************************************
function findsrc(workdir:string,f:string,appzip:text):text
 declarations
  lsf:list of text
 end-declarations

 if (sysname="windows" and f.size>2 and 
     (startswith(f,'\\') or getchar(f,2)=58)) or
    (sysname<>"windows" and getchar(f,1)=47) then
  if filexists(f) then
   returned:=f
  end-if
 else
  if returned="" and appzip<>"" then
   ! the zip file has been expanded in WKDIR
   findfiles(SYS_RECURS+SYS_NODIR,lsf,workdir+DIRSEP+"source",f)
   if lsf.size=1 then
    returned:=text("zlib.zip:"+appzip+",source/"+mkuxpath(f))
   end-if
  end-if

  if returned="" then
   forall(p in src_dirs) do
    returned:=p+DIRSEP+f
    if filexists(returned) then
     break
    else
     returned:=""
    end-if
   end-do
  end-if
 end-if
end-function

!****************************************************
! Count the number of lines of a file
!****************************************************
function countlines(f:text):integer
 declarations
  l:text
 end-declarations
 localsetparam("ioctrl",true)
 fopen(f,F_INPUT)
 if getparam("iostatus")=0 then
  while(readtextline(l)>0) do
   returned+=1
  end-do
 fclose(F_INPUT)
 else
  returned:=-1
 end-if
end-function

!****************************************************
!* Extract the file number form an lndx
!****************************************************
function lndx2file(l:integer):integer
 declarations
  FILESHIFT=-24
 end-declarations

 returned:=bitshift(l,FILESHIFT)
end-function

!****************************************************
!* Extract the line number from an lndx
!****************************************************
function lndx2line(l:integer):integer
 declarations
  LINEMASK=16777215
 end-declarations

 returned:=bittest(l,LINEMASK)
end-function

!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!********************************* TTY: Default report format (console)
declarations
 tty_ctx=record
 	   sttime:real
           endtestpxf:text
	   nbtests,nbskipped:integer
	   nbtodo:integer
         end-record
 procedure tty_logmsg(msglev:integer,tolog:...)
 procedure tty_startsuite(tslabel:text,nbtests:integer)
 procedure tty_endsuite
 procedure tty_logtest(starting:boolean,tres:s_test)
 procedure tty_fatalerror(ecode:integer,msg:text)
end-declarations

!*********************************
! TTY: Initialisation
!*********************************
procedure tty_init
 declarations
  ctx:tty_ctx
 end-declarations
 ctx.sttime:=gettime
 rctx:=->ctx
 fatalerror:=->tty_fatalerror
 logmsg:=->tty_logmsg
 logtest:=->tty_logtest
 suitestarted:=->tty_startsuite
 suitefinished:=->tty_endsuite
end-procedure

!*********************************
!* TTY: Output a message
!*********************************
procedure tty_logmsg(msglev:integer,tolog:...)
 if tolog.size<1 then
  fwriteln(output_fd)
 elif tolog.size=1 then
  fwriteln(output_fd,tolog(1))
 else
  def_out:=getfid(F_OUTPUT)
  fselect(output_fd)
  forall(i in 1..tolog.size-1)
   write(tolog(i))
  writeln(tolog(tolog.size))
  fselect(def_out)
 end-if
end-procedure

!*********************************
! TTY: Start test suite
!*********************************
procedure tty_startsuite(tslabel:text,nbtests:integer)
 rctx.tty_ctx.nbtests:=nbtests
 rctx.tty_ctx.nbtodo:=nbtests
end-procedure

!*********************************
! TTY: End test suite
!*********************************
procedure tty_endsuite
 return
end-procedure

!*********************************
! TTY: Logging before/after test
!*********************************
procedure tty_logtest(starting:boolean,tres:s_test)
 declarations
  toprt:text
 end-declarations
 with ctx=rctx.tty_ctx do
  if starting then	! Test starting
   if tres.num=1then
    writeln("-- Starting testing procedure --")
    ctx.sttime:=gettime
   end-if
   if NBW<=1 then
    toprt:=" + "+tres.label+":"
    write(toprt)
    if SHOWLOGS then
     writeln
     toprt:=" ====================== "+tres.label+":"
     ctx.endtestpxf:=toprt+if(toprt.size<TPLEN," "*(TPLEN-toprt.size),text(''))
    else
     if toprt.size<TPLEN then
      write(" "*(TPLEN-toprt.size))
     end-if
     fflush
    end-if
   end-if
  else					! Test finished
   ctx.nbtodo-=1
   if NBW>1 then
    toprt:=" + "+tres.label+if(LOGWKR,text(":["+tres.wid+"#"+tres.wnbt+"]"),text(":"))
    write(toprt)
    if SHOWLOGS then
     writeln
     showlogs(tres)
     toprt:=" ====================== "+tres.label+":"
     write(toprt)
    end-if
    if toprt.size<TPLEN then
     write(" "*(TPLEN-toprt.size))
    end-if
   end-if
   if tres.status=TST_SKIPPED then
    writeln(ctx.endtestpxf,cyellow,"Skipped (",tres.msg,")",cblack)
    ctx.nbskipped+=1
   elif tres.status<>TST_SUCCESS then
    writeln(ctx.endtestpxf,cred,tres.msg,"!!!",cblack)
   else
    writeln(ctx.endtestpxf,cgreen,formattext("Done in %.3fs",tres.time),cblack)
   end-if
   if ctx.nbtodo=0 then		! Last test finished: show report
    writeln("-- End of testing procedure --")
    writeln("Total time: ",formattext("%.3fs",gettime-ctx.sttime))
    if ctx.nbskipped=ctx.nbtests then
     writeln("No test run over ",ctx.nbtests)
    elif ctx.nbtests-ctx.nbskipped>1 then
     writeln(ctx.nbtests-ctx.nbskipped," tests were run over a total of ",ctx.nbtests)
    else
     writeln(1," test was run over a total of ",ctx.nbtests)
    end-if
    if nbfailed>0 then
     write(nbfailed," ",if(nbfailed>1,"tests","test")," failed. ")
     if LOGDIR<>"" then
      writeln("See log files under '",LOGDIR,"' for further details.")
     elif repfile<>'-' then
      writeln("See '",repfile,"' for further details.")
     else
      writeln
     end-if
    end-if
   end-if
  end-if
 end-do
end-procedure

!*********************************
! TTY: Fatal error and exit
!*********************************
procedure tty_fatalerror(ecode:integer,msg:text)
 tty_logmsg(MSL_ERR,"Fatal error: "+msg+"! Aborting.")
 exit(ecode)
end-procedure

!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!********************************* TC: Teamcity message service
declarations
 tc_ctx=record
         tclabels:dynamic array(integer) of text
	 tslabel:text
        end-record
 procedure tc_logmsg(msglev:integer,tolog:...)
 procedure tc_startsuite(tslabel:text,nbtests:integer)
 procedure tc_endsuite
 procedure tc_logtest(starting:boolean,tres:s_test)
 procedure tc_fatalerror(ecode:integer,msg:text)
 procedure tc_quote(t:text)
 function tc_getfile(f:string):text
 procedure tc_savelogs(tcl:text,tres:s_test)
end-declarations

!*********************************
! TC: Initialisation
!*********************************
procedure tc_init
 declarations
  ctx:tc_ctx
 end-declarations
 rctx:=->ctx
 logtest:=->tc_logtest
 logmsg:=->tc_logmsg
 fatalerror:=->tc_fatalerror
 suitestarted:=->tc_startsuite
 suitefinished:=->tc_endsuite
end-procedure

!*********************************
!* TC: Output a message
!*********************************
procedure tc_logmsg(msglev:integer,tolog:...)
 declarations
  msg:text
  stat:string
 end-declarations

 if tolog.size>0 then
  msg:=text(tolog(1))
  forall(i in 2..tolog.size)
   msg+=text(tolog(i))
  tc_quote(msg)
  case msglev of
   MSL_INF: stat:="NORMAL"
   MSL_WAR: stat:="WARNING"
   else     stat:="ERROR"
  end-case
  fwriteln(output_fd,"##teamcity[message text='",msg,"' status='",stat,"']")
 end-if
end-procedure

!*********************************
! TC: Start test suite
!*********************************
procedure tc_startsuite(tslabel:text,nbtests:integer)
 localsetparam("datetimefmt","%.y-%0m-%0dT%0H:%0M:%0S%0F")
 rctx.tc_ctx.tslabel:="moseltest-"+tslabel
 writeln("##teamcity[testSuiteStarted name='",rctx.tc_ctx.tslabel,"' timestamp='",datetime(SYS_NOW),"']")
end-procedure

!*********************************
! TC: End test suite
!*********************************
procedure tc_endsuite
 localsetparam("datetimefmt","%.y-%0m-%0dT%0H:%0M:%0S%0F")
 writeln("##teamcity[testSuiteFinished name='",rctx.tc_ctx.tslabel,"' timestamp='",datetime(SYS_NOW),"']")
 rctx.tc_ctx.tslabel:=""
end-procedure

!*********************************
! TC: Logging before/after test
!*********************************
procedure tc_logtest(starting:boolean,tres:s_test)
 with ctx=rctx.tc_ctx do
  if starting then	! Test starting
   ctx.tclabels(tres.num):=text("name='")+tres.label+"'"+
			if(NBW>1 and ASYNCOUT," flowId='mt"+tres.num+"'","")
   if NBW<2 or ASYNCOUT then
     writeln("##teamcity[testStarted ",ctx.tclabels(tres.num),"]")
   end-if
  else					! Test finished
   tclabel:=ctx.tclabels(tres.num)
   if NBW>1 then
    if not ASYNCOUT: writeln("##teamcity[testStarted ",tclabel,"]")
    if LOGWKR: writeln("##teamcity[testMetadata testName='",tres.label,
     			"' name='worker' value='",tres.wid,"#",tres.wnbt,"']")
   end-if
   tc_quote(tres.msg)
   if tres.status=TST_SKIPPED then
     writeln("##teamcity[testIgnored ",tclabel," message='",tres.msg,"']")
   elif tres.status<>TST_SUCCESS then
     writeln("##teamcity[testFailed ",tclabel," message='",tres.msg,"']")
   end-if
   if SAVELOGS or tres.status>=TST_ERROR: tc_savelogs(tclabel,tres)
   writeln("##teamcity[testFinished ",tclabel,formattext(" duration='%.0f'",tres.time*1000),"]")
   delcell(ctx.tclabels(tres.num))
  end-if
 end-do
end-procedure

!*********************************
! TC: Fatal error and exit
!*********************************
procedure tc_fatalerror(ecode:integer,msg:text)
 declarations
  toclose:set of integer
 end-declarations
 if rctx.tc_ctx.tslabel<>"" then
  if rctx.tc_ctx.tclabels.size>0 then
   toclose:=union(t in rctx.tc_ctx.tclabels.index(1)| exists(rctx.tc_ctx.tclabels(t))) {t}
   forall(t in toclose)
    tc_logtest(false,s_test(.status:=TST_ERROR,.msg:="aborting",.num:=t))
  end-if
  tc_endsuite
 end-if
 tc_logmsg(MSL_ERR,"Fatal error: "+msg+"! Aborting.")
 exit(ecode)
end-procedure

!*********************************
!* Quote a text string for TC
!*********************************
procedure tc_quote(t:text)
 asproc(regreplace(t,"[][|']",'|\0'))
 asproc(regreplace(t,"\n","|n"))
 asproc(regreplace(t,"\r",""))      ! from Windows (useless)
end-procedure

!*************************************
!* Generate a TC string from a file
!*************************************
function tc_getfile(f:string):text
 returned:=logfile2text(f)
 tc_quote(returned)
end-function

!*******************
! Save logs for TC
!*******************
procedure tc_savelogs(tcl:text,tres:s_test)
 if MAXLOGLEN>=0 then
  outfile:=outlog(tres)
  errfile:=errlog(tres)
  if isnonempty(outfile) then
   writeln("##teamcity[testStdOut ",tcl," out='",tc_getfile(outfile),"']")
  end-if
  if isnonempty(errfile) then
   writeln("##teamcity[testStdErr ",tcl," out='",tc_getfile(errfile),"']")
  end-if
 end-if
end-procedure

!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!********************************* TAP: Test Anything Protocol
declarations
 procedure tap_logmsg(msglev:integer,tolog:...)
 procedure tap_startsuite(tslabel:text,nbtests:integer)
 procedure tap_endsuite
 procedure tap_logtest(starting:boolean,tres:s_test)
 procedure tap_fatalerror(ecode:integer,msg:text)
 function tap_quote(t:text):text
 procedure tap_file2yaml(f:string,label:string)
 procedure tap_savelogs(tres:s_test)
end-declarations

!*********************************
! TC: Initialisation
!*********************************
procedure tap_init
 if rctx is not integer: rctx:=14
 writeln("TAP version ",rctx)
 logtest:=->tap_logtest
 logmsg:=->tap_logmsg
 fatalerror:=->tap_fatalerror
 suitestarted:=->tap_startsuite
 suitefinished:=->tap_endsuite
end-procedure

procedure tap13_init
 rctx:=13
 tap_init
end-procedure

!*************************************
!* TAP: Output a message as a comment
!*************************************
procedure tap_logmsg(msglev:integer,tolog:...)
 declarations
  msg:text
  lsm:list of text
 end-declarations

 if tolog.size>0 then
  msg:=text(tolog(1))
  forall(i in 2..tolog.size)
   msg+=text(tolog(i))
  lsm:=splittext(-1,msg,"\n")
  forall(m in lsm) do
   trim(m,SYS_RIGHT)
   writeln("# ",m)
  end-do
 end-if
end-procedure

!*********************************
! TAP: Start test suite
!*********************************
procedure tap_startsuite(tslabel:text,nbtests:integer)
 localsetparam("datetimefmt","%.y-%0m-%0dT%0H:%0M:%0S")
 writeln("# Started ",datetime(SYS_NOW))
 writeln("1..",nbtests)
end-procedure

!*********************************
! TAP: End test suite
!*********************************
procedure tap_endsuite
 localsetparam("datetimefmt","%.y-%0m-%0dT%0H:%0M:%0S")
 writeln("# Finished ",datetime(SYS_NOW))
end-procedure

!*********************************
! TAP: Logging before/after test
!*********************************
procedure tap_logtest(starting:boolean,tres:s_test)
 if not starting then	! end of test
  dsep:=if(rctx.integer=14," - "," ")
  if tres.status=TST_SKIPPED then
    writeln("ok ",tres.num,dsep,tap_quote(tres.label)," # SKIP ",tap_quote(tres.msg))
  else
   if tres.status<>TST_SUCCESS then
    writeln("not ok ",tres.num,dsep,tap_quote(tres.label))
   else
    writeln("ok ",tres.num,dsep,tap_quote(tres.label))
   end-if
   writeln("  ---")
   if NBW>1 and LOGWKR: writeln("  worker: '",tres.wid,"#",tres.wnbt,"'")
   writeln(formattext("  duration_ms: %.0f",tres.time*1000))
   if tres.msg<>'' : writeln("  message: ",quote(tres.msg,0,0))
   if SAVELOGS or tres.status>=TST_ERROR: tap_savelogs(tres)
   writeln("  ...")
  end-if
 end-if
end-procedure

!*********************************
! TAP: Fatal error and exit
!*********************************
procedure tap_fatalerror(ecode:integer,msg:text)
 writeln("Bail out! ",tap_quote(msg))
 exit(ecode)
end-procedure

!******************************
!* Quote a text string for TAP
!******************************
function tap_quote(t:text):text
 returned:=t
 if rctx.integer>=14 : asproc(regreplace(returned,'[#\\]','\\\0'))
 asproc(regreplace(returned,"\r",""))      ! from Windows (useless)
end-function

!****************************************************
!* Copy a file to the TAP stream as a YAML inclusion
!****************************************************
procedure tap_file2yaml(f:string,label:string)
 declarations
  l:text
 end-declarations
 writeln("    ",label,":")
 writeln("     File-Size: ",getfsize(f))
 writeln("     File-Name: ",label)
 writeln("     File-Type: text/plain")
(! Using a single line for base64 encoding
 fcopy(f,"mmssl.base64:nonl,text:tfile")
 writeln("     File-Content: ",tfile)
 reset(tfile)
!)
! Using multi-line base64
 writeln("     File-Content: |")
 fcopy(f,"mmssl.base64:tmp:b64")
 fopen("tmp:b64",F_INPUT)
 while(readtextline(l)>0) do
  write("      ",l)
 end-do
 fclose(F_INPUT)
 fdelete("tmp:b64")
end-procedure

!*******************
! Save logs for TAP
!*******************
procedure tap_savelogs(tres:s_test)
 if MAXLOGLEN>=0 then
  outfile:=outlog(tres)
  errfile:=errlog(tres)
  headprinted:=false
  if isnonempty(outfile) then
   writeln("  extensions:\n   Files:")
   headprinted:=true
   tap_file2yaml(outfile,"out_"+tres.num+".txt")
  end-if
  if isnonempty(errfile) then
   if not headprinted then
    writeln("  extensions:\n   Files:")
    headprinted:=true
   end-if
   tap_file2yaml(errfile,"err_"+tres.num+".txt")
  end-if
 end-if
end-procedure

!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!********************************* JUNIT: Teamcity message service
declarations
 jut_ctx=record
         tclabels:dynamic array(integer) of text
	 tslabel:text
	 logs:text
        end-record
 procedure jut_logmsg(msglev:integer,tolog:...)
 procedure jut_startsuite(tslabel:text,nbtests:integer)
 procedure jut_endsuite
 procedure jut_logtest(starting:boolean,tres:s_test)
 procedure jut_fatalerror(ecode:integer,msg:text)
 procedure jut_quote(t:text)
 function jut_getfile(f:string):text
 procedure jut_savelogs(tres:s_test)
end-declarations

!*********************************
! JUNIT: Initialisation
!*********************************
procedure jut_init
 declarations
  ctx:jut_ctx
 end-declarations
 rctx:=->ctx
 logtest:=->jut_logtest
 logmsg:=->jut_logmsg
 fatalerror:=->jut_fatalerror
 suitestarted:=->jut_startsuite
 suitefinished:=->jut_endsuite
end-procedure

!*********************************
!* JUNIT: Output a message
!*********************************
procedure jut_logmsg(msglev:integer,tolog:...)
 forall(m in tolog)
  rctx.jut_ctx.logs+=text(m)
 rctx.jut_ctx.logs+="\n"
end-procedure

!*********************************
! JUNIT: Start test suite
!*********************************
procedure jut_startsuite(tslabel:text,nbtests:integer)
 rctx.jut_ctx.tslabel:="moseltest-"+tslabel
 jut_quote(rctx.jut_ctx.tslabel)
 localsetparam("datetimefmt","%.y-%0m-%0dT%0H:%0M:%0S")
 writeln('<?xml version="1.0" encoding="UTF-8"?>')
 writeln("<testsuites>")
 writeln(' <testsuite name="',rctx.jut_ctx.tslabel,
         '" tests="',nbtests,
         '" timestamp="',datetime(SYS_NOW),'">')
end-procedure

!*********************************
! JUNIT: End test suite
!*********************************
procedure jut_endsuite
 localsetparam("datetimefmt","%.y-%0m-%0dT%0H:%0M:%0S")
 if rctx.jut_ctx.logs.size>0 then
  jut_quote(rctx.jut_ctx.logs)
  write("  <system-out>\n",rctx.jut_ctx.logs)
  if endswith(rctx.jut_ctx.logs,"\n") then
   writeln("  </system-out>")
  else
   writeln("\n  </system-out>")
  end-if
 end-if
 writeln(" </testsuite>\n</testsuites>")
 rctx.jut_ctx.tslabel:=""
end-procedure

!*********************************
! JUNIT: Logging before/after test
!*********************************
procedure jut_logtest(starting:boolean,tres:s_test)
 with ctx=rctx.jut_ctx do
  if starting then	! Test starting
   ctx.tclabels(tres.num):=tres.label
   jut_quote(ctx.tclabels(tres.num))
  else					! Test finished
   write('  <testcase name="',ctx.tclabels(tres.num),
         '" calssname="',ctx.tslabel,'" time="',
 	formattext("%.3f",tres.time),'"')
   if tres.status=TST_SKIPPED then
     writeln(">\n    <skipped message=\"",tres.msg,'"/>')
   elif tres.status=TST_ERROR then
     writeln(">\n    <error message=\"",tres.msg,'"/>')
   elif tres.status<>TST_SUCCESS then
     writeln(">\n    <failure message=\"",tres.msg,'"/>')
   elif not SAVELOGS and (NBW<2 or not LOGWKR) then
     writeln('/>')
   else
     writeln('>')
   end-if
   if NBW>1 and LOGWKR then
     writeln('    <properties>',
             '<property name="worker" value="',tres.wid,"#",tres.wnbt,'" />',
             '</properties>')
   end-if
   if SAVELOGS or tres.status>=TST_ERROR: jut_savelogs(tres)
   if tres.status<>TST_SUCCESS or SAVELOGS then
    writeln('  </testcase>')
   end-if
   delcell(ctx.tclabels(tres.num))
  end-if
 end-do
end-procedure

!*********************************
! JUNIT: Fatal error and exit
!*********************************
procedure jut_fatalerror(ecode:integer,msg:text)
 declarations
  toclose:set of integer
 end-declarations
 if rctx.jut_ctx.tslabel<>"" then
  if rctx.jut_ctx.tclabels.size>0 then
   toclose:=union(t in rctx.jut_ctx.tclabels.index(1)| exists(rctx.jut_ctx.tclabels(t))) {t}
   forall(t in toclose)
    jut_logtest(false,s_test(.status:=TST_ERROR,.msg:="aborting",.num:=t))
  end-if
  jut_logmsg(MSL_ERR,"Fatal error: "+msg+"! Aborting.")
  jut_endsuite
 else
  if rctx.jut_ctx.logs.size>0: fwrite(2,rctx.jut_ctx.logs)
  fwriteln(2,"Fatal error: "+msg+"! Aborting.")
 end-if
 exit(ecode)
end-procedure

!*********************************
!* Quote a text string for JUNIT
!*********************************
procedure jut_quote(t:text)
 asproc(regreplace(t,'\&','&amp;'))
 asproc(regreplace(t,"'",'&apos;'))
 asproc(regreplace(t,">",'&gt;'))
 asproc(regreplace(t,"<",'&lt;'))
 asproc(regreplace(t,'"','&quot;'))
 asproc(regreplace(t,"\r",""))      ! from Windows (useless)
end-procedure

!*************************************
!* Generate a JUNIT string from a file
!*************************************
function jut_getfile(f:string):text
 returned:=logfile2text(f)
 jut_quote(returned)
 if not endswith(returned,"\n"): returned+="\n"
end-function

!*******************
! Save logs for JUNIT
!*******************
procedure jut_savelogs(tres:s_test)
 if MAXLOGLEN>=0 then
  outfile:=outlog(tres)
  errfile:=errlog(tres)
  if isnonempty(outfile) then
   writeln("    <system-out>\n",jut_getfile(outfile),"    </system-out>")
  end-if
  if isnonempty(errfile) then
   writeln("    <system-err>\n",jut_getfile(errfile),"    </system-err>")
  end-if
 end-if
end-procedure

end-model
