(!******************************************************
  File moseltest.mos
  ``````````````````
  General Mosel testing framework

  author: Y. Colombani July 2015

  (c) Copyright 2015-2022 Fair Isaac Corporation

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

*******************************************************!)
model moseltest
version 0.5.5
uses 'mmsystem','mmjobs'

parameters
 SRCDIR="alltests"  ! Location of the tests or test file
 WKDIR="workdir"    ! Temporary directory for cwd
 DATADIR="data"     ! Temporary directory for saving data files
 DSODIR="dso"       ! Temporary dso directory
 LIBPATH=""         ! Paths to additional dso/bim (same syntax as $PATH)
 CONFLINE="!*!"     ! Tag for configuration lines
 ERR="err.txt"      ! Error log file (inside of workdir)
 OUT="out.txt"      ! Output file (inside of workdir)
 BASEREP="report"   ! Report file (after execution, in current directory)
 REPDATED=false     ! Generate unique report file using timestamp
 REPDATEFMT=""      ! Timestamp format for dated report files, eg "%.y%0m%0d%0H%0M%0S"
 REPRESET=true      ! Clear report file (false=>append to existing)
 KEEPDIR=false      ! Keep workdir/dsodir at the end of run
 PIDFILE=""         ! PID file for the xprmsrv server (''=>no xprmsrv)
 REPFILE=""         ! Report file (replaces BASEREP when defined)
 MAXWAIT=60*10      ! Maximum time to wait for an execution
 VALGRIND=false     ! Run tests with valgrind
 KEEPENV=false      ! Keep Mosel related environment variables
 LINELEN=80         ! Length of a line in the report
 TC=getenv("TEAMCITY_VERSION")<>"" ! Switch to Teamcity messaging
 TCMAXLOG=60000     ! Maximum length of a log file for Teamcity (characters)
 SAVELOGS=false     ! Keep example log even when successful
 LOGDIR=""          ! If defined, create separate log file per test

 COVLST=""          ! List of package/model/app names for coverage (separated by spaces)
 COVSRC=""          ! Paths to package/model sources (default: LIBPATH)
 COVDIR="coverage"  ! Directory where to save coverage reports
 COVREP=0           ! Format of the reports: 1: annotated source files; 2:lcov info file (3:both)
end-parameters

declarations
 DIRSEP=getdirsep
 PATHSEP=getpathsep
 OPTTYPES:array(OPTNAMES:set of string) of string
 Allfiles:list of text
 MOPT:dynamic array(set of string) of text
 reason,tcdur:text
 minst:Mosel
 mdr:Model
 nbfail:integer
 nbskipped:integer
 srcdir:text
 excludepat=["*.c9"+DIRSEP+"*"]
 pmvers:dynamic array(string) of integer
 pmvers_txt:dynamic array(string) of text

 sysname:string
 sysproc:string
 syshost:string
 sysarch:integer
 sysnaarch:string
 sysnaproc:string
 usenmake:boolean
 repfile:string
 repdate:text
 env_dsodir:text
 env_datadir:text
 env_clspath:text
 env_dsopath:text
 env_bimpfx:text
 tplen=LINELEN-22

 s_srcfile=
	record
	  path:text
	  rlines:range
	  nbl,nblh:integer
	  lincov:array(range) of integer
	  nbf,nbfh:integer
	  fctnames:array(range) of string
	  fctstart:array(range) of integer
	end-record
 srcfiles:dynamic array(allsrc:set of string) of s_srcfile
 bim_dirs:list of text
 src_dirs:list of text

 public tfile:text
! System names:
 KNOWNSYSNAMES={"aix","darwin","linux","hp-ux","sunos","windows"}
! A system name may include architecture like aix64/aix32
end-declarations

! Prototypes
forward function processtest(f:text,ft:integer,opts:array(string) of text,msg:text):boolean
forward procedure startinstance
forward procedure endinstance(discon:boolean)
forward procedure run_mdr(parms:text)
forward function execmos(torun:text,parms:text):integer
forward function dobuild(tobuild:text):boolean
forward function gettotest(path:text):list of text
forward procedure cleardir(p:text,rmd:boolean)
forward procedure copydir(src:text,dst:string)
forward function findmain(wkdir:text,totest:text):integer
forward function findmodel(wkdir:text,mtt:text):text
forward function expandapp(wkdir:text,path:text):text
forward procedure getopts(f:text,opts:array(set of string) of text)
forward procedure defsetenv
forward procedure updenv(env:text,spe:set of string)
forward function expenv(ev:text):text
forward function toskip(opts:array(set of string) of text,why:text):boolean
forward function splicfgline(line:text,val:text):string
forward function filexists(f:text):boolean
forward function direxists(f:text):boolean
forward function findpattern(rpat:text,f:text,rtmsg:text):boolean
forward function splitlist(t:text,sc:integer):list of text
forward function splitlist(t:text):list of text
forward function splitset(t:text):set of string
forward procedure savelogs(f:text,tcl:text)
forward procedure setsysdep
forward function safeload(m:Model,bf:string):boolean
forward function safecompile(opts:string,src:string,dst:string):integer
forward procedure startxsrv
forward procedure stopxsrv
forward function domake(f:text):boolean
forward function dorun(f:text):boolean
forward function getpmvers(p:string):integer
forward function build_lstdir(srcpath:string):list of text
forward procedure build_srcfiles(sfs:array(string) of s_srcfile,pkgs:list of text)
forward procedure savecovres(sfs:array(sf:set of string) of s_srcfile)
forward procedure reportcov(sfs:array(sf:set of string) of s_srcfile,covdir:text,mode:integer)

forward function tc_fixpath(p:text):text
forward procedure tc_quote(t:text)
forward function tc_getfile(f:string):text

! Known options (types: txt,int,boo,dbl,lst,lns):
! option lst: same as 'txt' but can appear several times (concatenated - sep=' ')
! option lsp: same as 'txt' but can appear several times (concatenated - sep=',')
! option lns: same as 'txt' but can appear several times (concatenated - sep='\n')
 OPTTYPES("runbefore"):="txt"	! model to run before main - exit 2 to skip test
 OPTTYPES("runafter"):="txt"	! model to run after main test
 OPTTYPES("outexpect"):="lns"	! regex to be found in output stream (in order)
 OPTTYPES("errexpect"):="lns"	! regex to be found in error stream (in order)
 OPTTYPES("compstat"):="int"	! expected compilation status (default=0)
 OPTTYPES("componly"):="boo"	! if true: compile only, no execution
 OPTTYPES("runstat"):="int"	! expected run status (default=0)
 OPTTYPES("exitcode"):="int"	! expected exit code (default=0)
 OPTTYPES("restart"):="boo"	! if true: restart instance after this test
 OPTTYPES("newinst"):="boo"	! if true: start a new instance for this test
 OPTTYPES("build"):="lst"	! list of packages/modules to build
 OPTTYPES("package"):="txt"	! =package name => not run, will be saved
 OPTTYPES("module"):="txt"	! =module name => not run, will be saved
 OPTTYPES("skip"):="boo"	! if true: skip this test
 OPTTYPES("skip_host"):="lst"	! list of host names where test is skipped
 OPTTYPES("skip_sys"):="lst"	! list of system names where test is skipped
 OPTTYPES("only_host"):="lst"	! list of host names where test is run
 OPTTYPES("only_sys"):="lst"	! list of system names where test is run
 OPTTYPES("setenv"):="lns"	! environment variable [sys.]<env>=<value>
 OPTTYPES("noerrmsg"):="boo"	! if true: error stream must be clear after run
 OPTTYPES("parms"):="lsp"	! list of parameters passed to the test model
 OPTTYPES("model"):="txt"	! model to run (valid only in a configuration file)
 OPTTYPES("save"):="lns"	! save specified file for use by another test
 OPTTYPES("restore"):="lns"	! restore specified file from a previous test
 OPTTYPES("required"):="lsp"	! list of packages/modules requited to run the test
 finalise(OPTNAMES)

! System specific settings
 setsysdep

! Here we go
 srcdir:=SRCDIR
 Allfiles:=gettotest(srcdir)
 if Allfiles.size<1 then
  writeln("Nothing to test!")
  exit(1)
 end-if

 makedir(WKDIR)
 cleardir(WKDIR,false)
 makedir(DSODIR)
 cleardir(DSODIR,false)
 makedir(DATADIR)
 cleardir(DATADIR,false)

 env_dsodir:=expandpath(DSODIR)
 env_datadir:=expandpath(DATADIR)
 bim_dirs:=build_lstdir(LIBPATH)
 env_dsopath:=expandpath(WKDIR)+PATHSEP+"."+PATHSEP+jointext(bim_dirs,PATHSEP)+PATHSEP+expandpath(DSODIR)
 env_clspath:=expandpath(getenv("XPRESSDIR")+"/lib/xprm.jar")+PATHSEP+
    expandpath(getenv("XPRESSDIR")+"/lib/xprd.jar")+PATHSEP+
    expandpath(getenv("XPRESSDIR")+"/lib/bindrv.jar")+PATHSEP+'.'
 if KEEPENV then
  env_bimpfx:=getenv("MOSEL_BIM")
  if getenv("MOSEL_DSO")<>"" then
   env_dsopath+=PATHSEP+getenv("MOSEL_DSO")
  end-if
 else
  env_bimpfx:=""
 end-if

 if TC then
  writeln("##teamcity[testSuiteStarted name='moseltest-",tc_fixpath(SRCDIR),"']")
 else
  writeln("Moseltest v",getparam("model_version"))
  writeln("Running Mosel v",pmvers_txt('mosel')," on `",syshost,
         "' (",sysname," ",sysarch,"bit)")
  writeln("Tests from ",SRCDIR)
 end-if

 if LOGDIR<>"" and not direxists(LOGDIR) then
  makepath(LOGDIR)
  if getsysstat<>0 or not direxists(LOGDIR) then
   writeln("Failed to create '",LOGDIR,"'!")
   exit(1)
  end-if
 end-if

 if COVLST.size>0 then
  writeln("Coverage mode enabled")
  src_dirs:=build_lstdir(if(COVSRC="",LIBPATH,COVSRC))
  build_srcfiles(srcfiles,splittext(COVLST," "))
  coverage:=true
  writeln
 end-if

 defsetenv
 startxsrv

 if not TC then
  writeln("-- Starting testing procedure --")
 end-if
 sttime:=gettime
 forall(f in Allfiles) do
  cleardir(WKDIR,false)
  if TC then
   tclabel:=text("name='")+tc_fixpath(f)+"'"
   writeln("##teamcity[testStarted ",tclabel,"]")
  else
   write(" + ",f,": ");
   if f.size+3+2<tplen then
    write(" "*(tplen-3-2-f.size))
   end-if
   fflush
  end-if
  if endswith(f,".mos") then
   fcopy(srcdir+'/'+f,WKDIR)
   totest:=pathsplit(SYS_FNAME,f)
   ftype:=0
  elif endswith(f,".c") then
   fcopy(srcdir+'/'+f,WKDIR)
   totest:=pathsplit(SYS_FNAME,f)
   ftype:=1
  elif endswith(f,".java") then
   fcopy(srcdir+'/'+f,WKDIR)
   totest:=pathsplit(SYS_FNAME,f)
   ftype:=2
  elif endswith(f,".tar") then
   untar(srcdir+'/'+f,WKDIR)
   ftype:=findmain(WKDIR,totest)
  elif endswith(f,".tgz") or endswith(f,".tar.gz")then
   untar("zlib.gzip:"+srcdir+'/'+f,WKDIR)
   ftype:=findmain(WKDIR,totest)
  elif endswith(f,".zip") then
   unzip(srcdir+'/'+f,WKDIR)
   ftype:=findmain(WKDIR,totest)
  elif endswith(f,".dir") then
   copydir(srcdir+'/'+f,WKDIR)
   ftype:=findmain(WKDIR,totest)
  elif endswith(f,".mcf") then
   fcopy(srcdir+'/'+f,WKDIR)
   totest:=pathsplit(SYS_FNAME,f)
   ftype:=3
  else
   if TC then
    writeln("##teamcity[testFailed ",tclabel," message='Unexpected file extention']")
    writeln("##teamcity[testFinished ",tclabel,"]")
   else
    writeln("Unexpected file extention for file ",f,"!!!")
   end-if
   nbfail+=1
   next
  end-if

  if totest.size>0 then
   getopts(totest,MOPT)
   if ftype=3 then
    totest:=findmodel(WKDIR,MOPT("model"))
   end-if
  end-if

  if totest.size<1 then
   if TC then
    writeln("##teamcity[testFailed ",tclabel," message='Main file was not found']")
    writeln("##teamcity[testFinished ",tclabel,"]")
   else
    writeln("Main file was not found in ",f,"!!!")
   end-if
   nbfail+=1
   next
  end-if

  tcdur:=""
  if toskip(MOPT,reason) then
   if TC then
    tc_quote(reason)
    writeln("##teamcity[testIgnored ",tclabel," message='",reason,"']")
   else
    writeln("Skipped (",reason,")")
   end-if
   nbskipped+=1
  elif processtest(totest,ftype,MOPT,reason) then
   nbfail+=1
   savelogs(f,tclabel)
   if TC then
    tc_quote(reason)
    writeln("##teamcity[testFailed ",tclabel," message='",reason,"']")
   else
    writeln(reason,"!!!")
   end-if
  elif TC then
   if startswith(reason,"Skip") then
    writeln("##teamcity[testIgnored ",tclabel," message='because of \"runbefore\"']")
   else
    tcdur:=text(" duration='")+reason+"'"
   end-if
   if SAVELOGS then savelogs(f,tclabel); end-if
  else
   writeln(reason)
   if SAVELOGS then savelogs(f,tclabel); end-if
  end-if

  if TC then
   writeln("##teamcity[testFinished ",tclabel,tcdur,"]")
  end-if
 end-do

 if not TC then
  writeln("-- End of testing procedure --")
  writeln("Total time: ",formattext("%.3fs",gettime-sttime))
 end-if

 disconnect(minst)
 stopxsrv
 if KEEPDIR and Allfiles.size=1 then
  writeln("Warning: directories '",WKDIR,"', '",DATADIR,"' and '",DSODIR,"' are not deleted")
 else
  cleardir(WKDIR,true)
  cleardir(DSODIR,true)
  cleardir(DATADIR,true)
 end-if

 if TC then
  writeln("##teamcity[testSuiteFinished name='moseltest-",tc_fixpath(SRCDIR),"']")
 else
  if nbskipped=Allfiles.size then
   writeln("No test run over ",Allfiles.size)
  elif Allfiles.size-nbskipped>1 then
   writeln(Allfiles.size-nbskipped," tests were run over a total of ",Allfiles.size)
  else
   writeln(Allfiles.size-nbskipped," test was run over a total of ",Allfiles.size)
  end-if
  if SAVELOGS then
   if LOGDIR<>"" then
    writeln("Log files have been saved under '",LOGDIR,"'.")
   else
    writeln("Log files have been saved in '",repfile,"'.")
   end-if
  end-if
  if nbfail>0 then
   write(nbfail," ",if(nbfail>1,"tests","test")," failed. ")
   if LOGDIR<>"" then
    writeln("See log files under '",LOGDIR,"' for further details.")
   else
    writeln("See '",repfile,"' for further details.")
   end-if
   exit(1)
  end-if
 end-if

 if coverage then
  reportcov(srcfiles,COVDIR,COVREP)
 end-if

!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!******************
!* Process a test
!******************
function processtest(f:text,ft:integer,opts:array(string) of text,msg:text):boolean
 declarations
  specenv:set of string
  rtmsg:text
 end-declarations

 fflush
 if opts("restore")<>"" then
  forall(fc in splitlist(opts("restore"),10)) do
   fcopy(DATADIR+'/'+fc,WKDIR)
   if getsysstat<>0 then
     msg:="Failed to restore file '"+fc+"'"
     returned:=true
     break
   end-if
  end-do
 end-if

 if not returned then
  updenv(opts("setenv"),specenv)
  if opts("newinst")="true" and specenv.size<1 then
   endinstance(true)
  end-if
  startinstance

  rbf:=execmos(opts("runbefore"),"")
  if rbf=2 then
   msg:="Skipped (runbefore)"
   nbskipped+=1
  elif rbf<>0 then
   msg:="Failed to run the 'runbefore' model"
   returned:=true
  elif dobuild(opts("build")) then
    msg:="Failed to process the build list ("+opts("build")+")"
    returned:=true
  else
   tstart:=gettime
   if ft=0 then					! Mosel file
    bimfile:=string(copytext(f,1,f.size-4)+".bim")
    c:=safecompile(if(coverage,"G","g"),string(f),bimfile)
    expstat:=if(opts("compstat")<>"",parseint(opts("compstat"),1),0)
    if c<>expstat then
     msg:="Compilation failed"
     returned:=true
    elif c=0 then
     if opts("componly")<>"true" and opts("package")="" then
      if(safeload(mdr,bimfile)) then
       msg:="Failed to load bimfile"
       returned:=true
      else
       if coverage then
        setcontrol(mdr,"runmode","2")
       end-if
       run_mdr(opts("parms"))
       expstat:=if(opts("runstat")<>"",parseint(opts("runstat"),1),0)
       expexcde:=if(opts("exitcode")<>"",parseint(opts("exitcode"),1),0)
       if minst.status<>0 or mdr.status<>expstat or mdr.exitcode<>expexcde then
        msg:="Execution error"
        returned:=true
       elif coverage then
        savecovres(srcfiles)
       end-if
       setparam("ioctrl",true)
        unload(mdr)
        asproc(getparam("iostatus"))
       setparam("ioctrl",false)
      end-if
     elif opts("package")<>"" then
      if not endswith(opts("package"),".bim") then opts("package")+=".bim"; end-if
      fcopy(WKDIR+"/"+bimfile,DSODIR+"/"+opts("package"))
     end-if
    end-if
   elif ft=3 then					! Bim file
    bimfile:=string(f)
    if(safeload(mdr,bimfile)) then
     msg:="Failed to load bimfile"
     returned:=true
    else
     if coverage then
      setcontrol(mdr,"runmode","2")
     end-if
     run_mdr(opts("parms"))
     expstat:=if(opts("runstat")<>"",parseint(opts("runstat"),1),0)
     expexcde:=if(opts("exitcode")<>"",parseint(opts("exitcode"),1),0)
     if minst.status<>0 or mdr.status<>expstat or mdr.exitcode<>expexcde then
      msg:="Execution error"
      returned:=true
     elif coverage then
      savecovres(srcfiles)
     end-if
     setparam("ioctrl",true)
      unload(mdr)
      asproc(getparam("iostatus"))
     setparam("ioctrl",false)
    end-if
   elif ft=1 then				! C file
    if opts("module")<>"" then
     execfile:=string(copytext(f,1,f.size-2)+".dso")
     if domake(execfile) then
      msg:="Compilation failed"
      returned:=true
     else
      fcopy(WKDIR+"/"+execfile,DSODIR+"/"+opts("module"))
     end-if
    else
     execfile:=string(copytext(f,1,f.size-2)+if(sysname="windows",".exe",""))
     if domake(execfile) then
      msg:="Compilation failed"
      returned:=true
     elif dorun(execfile) then
      msg:="Execution error"
      returned:=true
     end-if
    end-if
   elif ft=2 then				! Java file
    execfile:=string(copytext(f,1,f.size-5)+".class")
    if domake(execfile) then
     msg:="Compilation failed"
     returned:=true
    elif dorun(execfile) then
     msg:="Execution error"
     returned:=true
    end-if
   else
    msg:="Unknown file format"
    returned:=true
   end-if

   if minst.status<>0 then
    msg:="Mosel crashed"
    returned:=true
   end-if

   if not returned and execmos(opts("runafter"),"")<>0 then
    msg:="Failed to run the 'runafter' model"
    returned:=true
   end-if

   if not returned and opts("save")<>"" then
    forall(fc in splitlist(opts("save"),10)) do
     fcopy(WKDIR+"/"+fc,DATADIR)
     if getsysstat<>0 then
      msg:="Failed to save '"+fc+"'"
      returned:=true
      break
     end-if
    end-do
   end-if

   if not returned and findpattern(opts("outexpect"),WKDIR+"/"+OUT,rtmsg) then
    msg:=text("Failed to validate 'outexpect' (")+rtmsg+")"
    returned:=true
   end-if
   if not returned and findpattern(opts("errexpect"),WKDIR+"/"+ERR,rtmsg) then
    msg:=text("Failed to validate 'errexpect' (")+rtmsg+")"
    returned:=true
   end-if
   if not returned and opts("noerrmsg")="true" and getfsize(WKDIR+"/"+ERR)>0 then
    msg:="Error messages have been displayed"
    returned:=true
   end-if

   if not returned then
    if TC then
     msg:=formattext("%.0f",(gettime-tstart)*1000)
    else
     msg:=formattext("Done in %.3fs",gettime-tstart)
    end-if
   end-if
  end-if

  if specenv.size>0 then
   forall(s in specenv)
    setenv(s,"")
   defsetenv             ! Restore defaults
   endinstance(true)
  else
   endinstance(opts("restart")="true")
  end-if

  if not returned and minst.status=-3 then
   msg:="Abnormal instance termination"
   returned:=true
  end-if
 end-if
end-function

!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!****************************************
!* Prepare the Mosel instance for a run
!****************************************
procedure startinstance
 if minst.status<>0 then
  valgrind:=if(VALGRIND,'valgrind --num-callers=20 ','')
  if connect(minst,'rcmd:'+valgrind+'mosel -r -d "'+expandpath(WKDIR)+
                                   '" -dp "'+env_dsopath+'"')<>0  then
   writeln("Fatal error: failed to start Mosel instance")
   exit(2)
  end-if
 end-if
 setcontrol(minst,"lang","en")
 outpath:=string(expandpath(text(WKDIR)+"/"+OUT))
 errpath:=string(expandpath(text(WKDIR)+"/"+ERR))
 setdefstream(minst,F_INPUT,"null:")
 setdefstream(minst,F_OUTPUT+F_LINBUF,outpath)
 setdefstream(minst,F_ERROR+F_LINBUF,errpath)
 fcopy("tmp:makefile",WKDIR+"/makefile")
end-procedure

!**************************************
!* Clean up Mosel instance after a run
!**************************************
procedure endinstance(discon:boolean)
 unload(mdr)
 if discon or minst.status<>0 then
  disconnect(minst)
 else
  setparam("ioctrl",true)
   setdefstream(minst,"null:","","")
   iost:=getparam("iostatus")
  setparam("ioctrl",false)
  if iost<>0 then  ! instance crashed
   disconnect(minst)
  end-if
 end-if
end-procedure

!***********************************
!* Run the model mdr on minst
!***********************************
procedure run_mdr(parms:text)
 run(mdr,parms)
 waitfor(EVENT_END,MAXWAIT,WAIT_EXACT)
 if waitexpired then
  if not TC then
   write("(killed) "); fflush
  end-if
  stop(mdr)
  waitfor(EVENT_END,20,WAIT_EXACT)
  if waitexpired then
   kill(minst)
   waitfor(EVENT_END,-1,WAIT_EXACT)
  end-if
 end-if
 dropnextevent
end-procedure

!***********************************
!* Execute a model on the instance
!***********************************
function execmos(torun:text,parms:text):integer
 if torun<>"" then
  if safecompile("g",string(torun),"tmp:bimfile")<>0 or
     safeload(mdr,"tmp:bimfile") then
   returned:=-1
  else
   run_mdr(parms)
   if mdr.status<>0 then
    returned:=-2
   else
    returned:=mdr.exitcode
   end-if
   unload(mdr)
  end-if
 end-if
end-function

!********************************************
!* Build what has to be built before the run
!********************************************
function dobuild(tobuild:text):boolean
 declarations
  lsb:list of text
 end-declarations

 if tobuild<>"" then
  lsb:=splitlist(tobuild)
  forall(td in lsb) do
   if endswith(td,".bim") then
    if safecompile("g",string(copytext(td,1,td.size-4)+".mos"),
                                                string(td))<>0 then
     returned:=true
     break
    end-if
   elif domake(td) then
    returned:=true
    break
   end-if
  end-do
 end-if
end-function

!***************************
!* Get all files to be run
!***************************
function gettotest(path:text):list of text
 declarations
  f:text
  lsf:list of text
  allexcludepat=["*.dir"+DIRSEP+"*"]+excludepat
 end-declarations

 while (path.size>1 and endswith(path,DIRSEP))
  deltext(path,path.size,path.size)

 if filexists(path) then
  f:=pathsplit(SYS_FNAME,path,path)
  returned:=[f]
 elif endswith(path,".dir") and bittest(getfstat(path), SYS_TYP)=SYS_DIR then
  f:=pathsplit(SYS_FNAME,path,path)
  returned:=[f]
 else
  findfiles(SYS_RECURS+SYS_NODIR,lsf,path,"*.mos|*.c|*.java|*.zip|*.tar|*.tgz|*.tar.gz|*.mcf")
  forall(l in lsf)
   if and(pat in allexcludepat) not pathmatch(l,pat) then
    returned+=[l]
   end-if
  lsf:=[]
  findfiles(SYS_RECURS+SYS_DIRONLY,lsf,path,"*.dir")
  forall(l in lsf)
   if and(pat in excludepat) not pathmatch(l,pat) then
    returned+=[l]
   end-if
  qsort(SYS_UP,returned)
 end-if
end-function

!*********************
!* Clear a directory
!*********************
procedure cleardir(p:text,rmd:boolean)
 declarations
  lsf:list of text
 end-declarations

 if minst.status=0 then
  ! If we have built modules, unload them before cleanup
  findfiles(SYS_NODIR+SYS_NOSORT,lsf,p,"*.dso")
  if lsf.size>0 then
   ! 'flushdso' available in Mosel 3.13.1 and newer
   setparam("ioctrl",true)
    setcontrol(minst,"flushdso","")
    asproc(getparam("iostatus"))
   setparam("ioctrl",false)
  end-if
 end-if

 ! Firstly remove files only
 removefiles(SYS_RECURS+SYS_NODIR,p,"*")

 if getsysstat<>0 then
  writeln("Failed to remove files from ",p)
 else
  if sysname="windows" then
   ! Under Windows there may remain dso/exe files still loaded, these will have
   ! been marked for deletion & will be actually deleted once they are unloaded.
   allgone:=false
   forall(i in 0..120) do
    if i>0 then sleep(500); end-if
    lsf:=[]
    findfiles(SYS_RECURS+SYS_NODIR+SYS_NOSORT,lsf,p,"*")
    if getsize(lsf)=0 then allgone:=true; break; end-if
   end-do
   if not allgone then
    writeln("Unable to remove all files from ",p,", remaining files: ",lsf)
   end-if
  end-if
  ! second round to remove directories
  removefiles(SYS_RECURS,p,"*")
 end-if

 if rmd then
  removedir(p)
 end-if
end-procedure

!*************************
!* Copy a directory tree
!*************************
procedure copydir(src:text,dst:string)
 declarations
  lsf:list of text
 end-declarations
 findfiles(SYS_RECURS,lsf,src,"*")
 if lsf.size>0 then
  newtar(0,"tmp:ttar",src,lsf)
  untar("tmp:ttar",dst)
  if getsysstat <> 0 then
   writeln('Could not copy files from "',src,'" to "',dst,'"!')
  end-if
  fdelete("tmp:ttar")
 end-if
end-procedure

!**************************************
!* Find the "main" file in a directory
!**************************************
function findmain(wkdir:text,totest:text):integer
 declarations
  lsf:list of text
 end-declarations

 totest:=""
 returned:=-1

 findfiles(SYS_NODIR,lsf,wkdir,"main.mos|main.c|Main.java|main.java|main.mcf")
 if lsf.size<>1 then
  lsf:=[]
  findfiles(SYS_NODIR,lsf,wkdir,"*.mos|*.c|*.java|*.mcf")
 end-if

 if lsf.size=1 then
  totest:=lsf.first
  forall(e in [".mos",".c",".java",".mcf"],i as counter)
   if endswith(totest,e) then
    returned:=i-1
    break
   end-if
 end-if
end-function

!******************************************
!* Find the model file of a configuration
!******************************************
function findmodel(wkdir:text,mtt:text):text
 if mtt<>"" then
  if not endswith(mtt,".bim") and not endswith(mtt,".zip") then
   mtt+=".bim"
  end-if
  forall(pfx in bim_dirs) do
   path:=expandpath(pfx+DIRSEP+mtt)
   if filexists(path) then
    if endswith(mtt,".zip") then
     returned:=expandapp(wkdir,path)
    else
     fcopy(path,wkdir)
     returned:=mtt
    end-if
    break
   end-if
  end-do
 end-if
end-function

!***********************************
!* Expand an application zip-file
!***********************************
function expandapp(wkdir:text,path:text):text
 declarations
  lsf:list of text
 end-declarations

 unzip(path,wkdir)
 if getsysstat<>0 then
  writeln("Failed to extract zip file '",path,"'")
 else
  findfiles(SYS_NODIR,lsf,wkdir,"*.bim")
  if lsf.size=1 then
   returned:=lsf(1)
   reset(lsf)
   findfiles(SYS_NODIR,lsf,wkdir,"model_resources/*")
   forall(f in lsf)
    fcopy(wkdir+DIRSEP+f,wkdir)
  end-if
 end-if
end-function

!***********************************
!* Process options of a source file
!***********************************
procedure getopts(f:text,opts:array(set of string) of text)
 declarations
  line,val:text
  parm:string
 end-declarations

 delcell(opts)
 fopen(WKDIR+"/"+f,F_INPUT)
 while(readtextline(line)>=0) do
  trim(line)
  if startswith(line,CONFLINE) then
   deltext(line,1,CONFLINE.size)
   parm:=splicfgline(line,val)
   if parm in OPTNAMES then
    if val="" then
     delcell(opts(parm))
    elif OPTTYPES(parm)='lst' and opts(parm).size>0 then
     opts(parm)+=' '+val
    elif OPTTYPES(parm)='lsp' and opts(parm).size>0 then
     opts(parm)+=','+val
    elif OPTTYPES(parm)='lns' and opts(parm).size>0 then
     opts(parm)+="\n"+val
    else
     opts(parm):=val
    end-if
   else
    writeln("   Warning: option `",if(parm.size>0,text(parm),line),
            "' ignored (file ",f,")")
   end-if
  end-if
 end-do
 fclose(F_INPUT)
end-procedure

!************************************
!* Set default environment variables
!************************************
procedure defsetenv
 setenv("DSODIR",env_dsodir)
 setenv("DATADIR",env_datadir)
 setenv("MOSEL_DSO",env_dsopath)   ! For submodels created by worker
 setenv("MOSEL_BIM",env_bimpfx)    ! For submodels created by worker
 setenv("CLASSPATH",env_clspath)
end-procedure

!**********************************
!* Update environment if requested
!**********************************
procedure updenv(env:text,spe:set of string)
 declarations
  mp:array(0..3) of textarea
  lp:list of text
 end-declarations

 lp:=splitlist(env,10)
 forall(e in lp) do
  trim(e)
  if regmatch(e,'^([-a-z0-9]+)\.([A-Za-z0-9_]+) *=(.*)',1,REG_EXTENDED,mp) then
   esys:=copytext(e,mp(1))
   if esys<>sysname and esys<>sysnaarch then
    if endswith(esys,"32") or endswith(esys,"64") then
     deltext(esys,esys.size-1,esys.size)
    end-if
    if string(esys) not in KNOWNSYSNAMES then
     writeln("Warning: option `setenv ",e,"' ignored (unknown system name)")
    end-if
    next
   else
    ename:=copytext(e,mp(2))
    eval:=copytext(e,mp(3))
   end-if
  elif regmatch(e,'^([A-Za-z0-9_]+) *=(.*)',1,REG_EXTENDED,mp) then
   ename:=copytext(e,mp(1))
   eval:=copytext(e,mp(2))
  else
   writeln("Warning: option `setenv ",e,"' ignored (syntax error)")
   next
  end-if
  spe+={string(ename)}
  setenv(ename,expenv(eval))
 end-do

 ! If new variables have been defined, restart Mosel instance
 if spe.size>0 then
  endinstance(true)
 end-if
end-procedure

!***************************************
!* Expand ${} for environment variables
!***************************************
function expenv(ev:text):text
 declarations
  mp:array(0..1) of textarea
 end-declarations

 returned:=ev
 while(regmatch(returned,'\${\([A-Za-z_][A-Za-z0-9_]*\)}',1,0,mp)) do
  eval:=getenv(copytext(returned,mp(1)))
  deltext(returned,mp(0))
  if eval.size>0 then
   inserttext(returned,eval,mp(0).start)
  end-if
 end-do
end-function

!*****************************************
!* Check whether a test should be skipped
!*****************************************
function toskip(opts:array(set of string) of text,why:text):boolean
 declarations
  mp:array(0..3) of textarea
 end-declarations

 if opts("skip")="true" then
  why:="disabled"
  returned:=true
 else
  if opts("skip_host")<>"" then
   lsn:=splitset(opts("skip_host"))
   if syshost in lsn then
    why:="on this host"
    returned:=true
   end-if
  end-if
  if not returned and opts("skip_sys")<>"" then
   lsn:=splitset(opts("skip_sys"))
   if sysname in lsn or sysnaarch in lsn or 
      sysproc in lsn or sysnaproc in lsn then
    why:="on this system"
    returned:=true
   end-if
  end-if
  if not returned and opts("only_host")<>"" then
   lsn:=splitset(opts("only_host"))
   if syshost not in lsn then
    why:="on this host"
    returned:=true
   end-if
  end-if
  if not returned and opts("only_sys")<>"" then
   lsn:=splitset(opts("only_sys"))
   if sysname not in lsn and sysnaarch not in lsn and
      sysproc not in lsn and sysnaproc not in lsn  then
    why:="on this system"
    returned:=true
   end-if
  end-if
  if not returned and opts("required")<>"" then
   forall(p in splittext(opts("required"),","))
    if regmatch(p,' *\([-_.a-zA-Z0-9]*\) *\([<>]\) *\([0-9][0-9.]*\)',1,0,mp) then
     m:=string(copytext(p,mp(1)))
     mv:=copytext(p,mp(3))
     d:=copytext(p,mp(2))
     v:=getpmvers(m)
     if v<0 then
      why:=text("missing '")+m+"'"
      returned:=true
     else
      reset(mp)
      if regmatch(mv,'\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)',1,0,mp) then
       mvn:=parseint(mv,mp(1))*1000000+parseint(mv,mp(2))*1000+parseint(mv,mp(3))
      elif regmatch(mv,'\([0-9]*\)\.\([0-9]*\)',1,0,mp) then
       mvn:=parseint(mv,mp(1))*1000000+parseint(mv,mp(2))*1000
      else
       mvn:=parseint(mv,1)*1000000
      end-if
      if (d=">" and v<mvn) or (d="<" and v>mvn) then
       why:="incompatible version of '"+m+"' ("+pmvers_txt(m)+d+mv+")"
       returned:=true
      end-if
     end-if
    else
     writeln("Malformed 'required' tag '",p,"' (ignored)")
    end-if
  end-if
 end-if
end-function

!*******************************************
!* Split a line of the form name |:|= value
!*******************************************
function splicfgline(line:text,val:text):string
 declarations
  mp:array(0..2) of textarea
  dv:real
 end-declarations
 trim(line)
 if regmatch(line,'^\([a-zA-Z0-9_]*\) *[ :=] *\(.*\)',1,0,mp) then
  returned:=string(copytext(line,mp(1)))
  val:=copytext(line,mp(2))
  trim(val)
  if val.size>0 and returned in OPTNAMES then
   case OPTTYPES(returned) of
    'int': do
	 dv:=parseint(val,1)
	 if getparam("sys_endparse")<>val.size+1 or getsysstat<>0 then
	  returned:=""
	 end-if
	end-do
    'boo': do
	 val:=tolower(val)
	 if val<>"true" and val<>"false" then
	  returned:=""
	 end-if
	end-do
    'dbl': do
	 dv:=parsereal(val,1)
	 if getparam("sys_endparse")<>val.size+1 or getsysstat<>0 then
	  returned:=""
	 end-if
	end-do
    ! else: text
   end-case
  end-if
 ! Special case of a Boolean tag (only the name of the tag for 'true')
 elif regmatch(line,'^\([a-zA-Z0-9_]*\)$',1,0,mp) then
  returned:=string(copytext(line,mp(1)))
  if returned in OPTNAMES and OPTTYPES(returned)='boo' then
   val:="true"
  else
   returned:=""
   val:=""
  end-if
 end-if
end-function

!****************************************************
!* Check whether a file exists and is a regular file
!****************************************************
function filexists(f:text):boolean
 fstat:=getfstat(f)
 if fstat<>0 then
  returned:=bittest(fstat,SYS_TYP)=SYS_REG and bittest(fstat,SYS_MOD)>=SYS_READ
 ! else: returned:=false
 end-if
end-function

!****************************************************
!* Check whether a file exists and is a directory
!****************************************************
function direxists(f:text):boolean
 fstat:=getfstat(f)
 if fstat<>0 then
  returned:=bittest(fstat,SYS_TYP)=SYS_DIR and bittest(fstat,SYS_MOD)>=SYS_READ
 ! else: returned:=false
 end-if
end-function

!************************************
!* Look for a pattern in a log file
!************************************
function findpattern(rpat:text,f:text,rtmsg:text):boolean
 declarations
  mp:array(0..0) of textarea
  line:text
  lp:list of text
  cnt:integer
 end-declarations

 if rpat<>"" then
  lp:=splitlist(rpat,10)
  if not filexists(f) then
   returned:=true
   rtmsg:=formattext("#1: %s",lp.first)
  else
   fopen(f,F_INPUT)
   returned:=true
   cnt:=1
   p:=string(lp.first)
   while(readtextline(line)>=0) do
    if regmatch(line,p,1,REG_EXTENDED,mp) then
     cuthead(lp,1)
     if lp.size=0 then
      returned:=false
      break
     else
      p:=string(lp.first)
      cnt+=1
     end-if
    end-if
   end-do
   fclose(F_INPUT)
   rtmsg:=if(returned,formattext("#%d: %s",cnt,lp.first),text(""))
  end-if
 else
  reset(rtmsg)
 end-if
end-function

!****************************************************
!* Split a list of names (with choice of separator)
!****************************************************
function splitlist(t:text,sc:integer):list of text
 declarations
  pctx:parsectx
 end-declarations

 pctx.sepchar:=sc
 if sc=10 then  ! no quoting when splitting full lines
  pctx.qtype:=-1
 end-if
 while(nextfield(t,pctx)) do
  returned+=[parsetext(t,pctx)]
 end-do
end-function

!*************************
!* Split a list of names
!*************************
function splitlist(t:text):list of text
 returned:=splitlist(t,32)
end-function

!************************
!* Split a set of names
!************************
function splitset(t:text):set of string
 declarations
  pctx:parsectx
 end-declarations

 pctx.sepchar:=32  ! ' '
 while(nextfield(t,pctx)) do
  returned+={string(parsetext(t,pctx))}
 end-do
end-function

!******************
!* Save log files
!******************
procedure savelogs(f:text,tcl:text)
 declarations
  lfname: text
 end-declarations
 if TC then
  if filexists(WKDIR+"/"+OUT) and getfsize(WKDIR+"/"+OUT)>0 then
   writeln("##teamcity[testStdOut ",tcl," out='",tc_getfile(WKDIR+"/"+OUT),"']")
  end-if
  if filexists(WKDIR+"/"+ERR) and getfsize(WKDIR+"/"+ERR)>0 then
   writeln("##teamcity[testStdErr ",tcl," out='",tc_getfile(WKDIR+"/"+ERR),"']")
  end-if
 end-if
 if LOGDIR="" then
  fopen(repfile,F_OUTPUT+F_APPEND)
  writeln("+"*78)
  writeln(if(f.size<77,"="*(77-f.size),text("=="))," ",f)
  if filexists(WKDIR+"/"+OUT) and getfsize(WKDIR+"/"+OUT)>0 then
   writeln("==== ","output"," ====")
  end-if
  fclose(F_OUTPUT)
  fcopy(WKDIR+"/"+OUT,F_SILENT,repfile,F_APPEND)
  if filexists(WKDIR+"/"+ERR) and getfsize(WKDIR+"/"+ERR)>0 then
   fopen(repfile,F_OUTPUT+F_APPEND)
   writeln("==== ","error"," ====")
   fclose(F_OUTPUT)
   fcopy(WKDIR+"/"+ERR,F_SILENT,repfile,F_APPEND)
  end-if
 else
  ff:=copytext(f,1,f.size)
  asproc(regreplace(ff,'([/:\\])',"_",1,REG_EXTENDED))
  if filexists(WKDIR+"/"+OUT) and getfsize(WKDIR+"/"+OUT)>0 then
    lfname:=OUT
    if repdate<>"" then
      asproc(pathsplit(SYS_EXTN,lfname,lfname))
      lfname+=repdate+".txt"
    end-if
    fcopy(WKDIR+"/"+OUT,LOGDIR+"/"+ff+"_"+lfname)
  end-if
  if filexists(WKDIR+"/"+ERR) and getfsize(WKDIR+"/"+ERR)>0 then
    lfname:=ERR
    if repdate<>"" then
      asproc(pathsplit(SYS_EXTN,lfname,lfname))
      lfname+=repdate+".txt"
    end-if
    fcopy(WKDIR+"/"+ERR,LOGDIR+"/"+ff+"_"+lfname)
  end-if
 end-if
end-procedure

!**********************************
!* Prepare system dependent stuff
!**********************************
procedure setsysdep
 sysname:=string(tolower(getsysinfo(SYS_NAME)))
 sysarch:=integer(getsysinfo(SYS_ARCH))
 sysproc:=string(tolower(getsysinfo(SYS_PROC)))
 sysnaarch:=sysname+sysarch
 sysnaproc:=sysname+"-"+sysproc
 syshost:=getsysinfo(SYS_NODE)

 asproc(getpmvers('mosel'))
 pmvers(""):=-1

 if sysname="windows" then
   ! use nmake if it is available
   fopen("null:",F_OUTPUT)
   fopen("null:",F_ERROR)
   system("nmake /nologo /?")
   fclose(F_ERROR)
   fclose(F_OUTPUT)
   usenmake := getsysstat = 0
   if not usenmake then
     writeln("WARNING: Could not find 'nmake'! Using 'make'.")
   end-if
 end-if

 if REPDATED then
  if REPDATEFMT<>"": localsetparam("datetimefmt",REPDATEFMT)
  repdate:=text("_")+text(datetime(SYS_NOW))
 end-if
 if REPFILE<>"" then
  repfile:=REPFILE
 else
  repfile:=BASEREP+repdate+".txt"
 end-if
 if REPRESET then
  fdelete(repfile)
 end-if
 fopen("tmp:makefile",F_OUTPUT)
 writeln(".SUFFIXES: .bim .mos .dso .java .class")
 if sysname="windows" then
  if sysarch=32 then
   writeln('CFLAGS=/nologo /Zi /MD /I"$(XPRESSDIR)\include"')
  else
   writeln('CFLAGS=/nologo /Zi /MD /GS- /I"$(XPRESSDIR)\include"')
  end-if
  writeln(`WIN32
.c.exe:
	$(CC) $(CFLAGS) $< /link /libpath:"$(XPRESSDIR)\lib" xprm_mc.lib xprm_rt.lib xprd.lib bindrvMD.lib
.c.dso:
	$(CC) $(CFLAGS) /LD $< /Fe$*.dso
.mos.bim:
	mosel compile -g $*.mos
.java.class:
	javac $*.java
WIN32`)
 else				! 32bit Unix
  if sysarch=32 then
   case sysname of
    "linux":writeln(`LIN32
CFLAGS=-m32 -D_REENTRANT -I$(XPRESSDIR)/include
MAKEDSO=$(CC) -m32 -shared
LIN32`)
    "sunos":writeln(`SOL32
CFLAGS=-D_REENTRANT -Kpic -I$(XPRESSDIR)/include
LDFLAGS=-lrt -lsocket -lnsl -lm
MAKEDSO=$(LD) -G
SOL32`)
    "hp-ux":writeln(`HP32
CFLAGS=+Z +DAportable -D_POSIX_C_SOURCE=199506L -I$(XPRESSDIR)/include
LDFLAGS=-lm -Wl,+s
MAKEDSO=$(LD) -b +s
HP32`)
    "aix":writeln(`AIX32
CFLAGS=-q32 -D_THREAD_SAFE -I$(XPRESSDIR)/include
LDFLAGS=-lm -brtl
MAKEDSO=$(CC) -G -q32 -brtl
AIX32`)
   end-case
  else				! 64bit Unix
   case sysname of
    "linux":
	if sysproc="aarch64" then
         writeln(`AARCH64
CFLAGS=-fpic -D_REENTRANT -I$(XPRESSDIR)/include
LDFLAGS=
MAKEDSO=$(CC) -shared
AARCH64`)
	else
         writeln(`LIN64
CFLAGS=-m64 -fpic -D_REENTRANT -I$(XPRESSDIR)/include
LDFLAGS=-fopenmp
MAKEDSO=$(CC) -m64 -shared
LIN64`)
	end-if
    "sunos":writeln(`SOL64
CFLAGS=-m64 -D_REENTRANT -Kpic -I$(XPRESSDIR)/include
LDFLAGS=-lrt -lsocket -lnsl -lm
MAKEDSO=$(LD) -G
SOL64`)
    "hp-ux":writeln(`HP64
CFLAGS=+Z +DD64 -D_POSIX_C_SOURCE=199506L -I$(XPRESSDIR)/include
LDFLAGS=-lm -Wl,+s
MAKEDSO=$(LD) -b +s
HP64`)
    "aix":writeln(`AIX64
CFLAGS=-q64 -D_THREAD_SAFE -I$(XPRESSDIR)/include
LDFLAGS=-lm -brtl
MAKEDSO=$(CC) -G -q64 -brtl
AIX64`)
    "darwin":writeln(`MAC
CFLAGS=-m64 -I$(XPRESSDIR)/include
MAKEDSO=$(CC) -m64 -dynamiclib
MAC`)
   end-case
  end-if
  writeln(`UNX
.c:
	$(CC) $(CFLAGS) $(LDFLAGS) $< -L$(XPRESSDIR)/lib -lxprm_mc -lxprm_rt -lxprd -lbindrv -lpthread -o $*
.c.dso:
	$(CC) -c $(CFLAGS) $<
	$(MAKEDSO) $*.o -o $*.dso
.mos.bim:
	mosel compile -g $*.mos
.java.class:
	javac $*.java
UNX`)
  end-if
  fclose(F_OUTPUT)
end-procedure

!************************************
!* Load a model on 'minst' "safely"
!************************************
function safeload(m:Model,bf:string):boolean
 localsetparam("ioctrl",true)
 load(minst,m,bf)
 returned:= getparam("iostatus")<>0
end-function

!***************************************
!* Compile a model on 'minst' "safely"
!***************************************
function safecompile(opts:string,src:string,dst:string):integer
 localsetparam("ioctrl",true)
 returned:=compile(minst,opts,src,dst)
 asproc(getparam("iostatus"))
end-function

!***************************
!* Start an xprmsrv server
!***************************
procedure startxsrv
 declarations
  inst:Mosel
 end-declarations

 if PIDFILE<>"" then
  fopen("null:",F_ERROR)
  c:=connect(inst,"127.0.0.1")
  fclose(F_ERROR)
  if c=0 then
   disconnect(inst)
   writeln("Warning: using an existing xprmsrv server - remote tests may fail")
  else
   fopen("tmp:xcfg",F_OUTPUT)
   writeln("XPRMSRV_ACCESS=127.0.0.1 ",getsysinfo(SYS_NODE))
   writeln("[xpress]")
   writeln("MOSEL_CWD=",expandpath(WKDIR))
   fclose(F_OUTPUT)
   system("xprmsrv -tm 3600 -d -pf "+PIDFILE+" "+expandpath("tmp:xcfg"))
   writeln("xprmsrv server started")
  end-if
 end-if
end-procedure

!***************************
!* Stop the xprmsrv server
!***************************
procedure stopxsrv
 if PIDFILE<>"" and filexists(PIDFILE) then
  fcopy(PIDFILE,"text:tfile")
  if sysname="windows" then
  ! Win32: no way to kill a process from a 32bit process on a 64bit system...
   system("tskill "+tfile)
!   system("taskkill /F /PID "+tfile)
   if getsysstat=0 then
    fdelete(PIDFILE)
    writeln("xprmsrv server stopped")
   else
    writeln("Warning: failed to kill xprmsrv server (pid:",tfile,")")
   end-if
  else
   system("kill "+tfile)
   writeln("xprmsrv server stopped")
  end-if
 end-if
end-procedure

!*****************************************
!* Execute 'make' on the remote instance
!*****************************************
function domake(f:text):boolean
 fopen("tmp:domake.mos",F_OUTPUT)
 writeln(`DOMAKE
model domake
uses 'mmsystem'
parameters
 TODO=""
end-parameters
DOMAKE`)

 if usenmake then
  writeln('system("nmake /nologo "+TODO)')
 else
  writeln('system("make "+TODO)')
 end-if

 writeln(`DOMAKE
exit(getsysstat)
end-model
DOMAKE`)
 fclose(F_OUTPUT)
 returned:=execmos("rmt:tmp:domake.mos",text("TODO=")+f)<>0
end-function

!********************************************
!* Run an executable on the remote instance
!********************************************
function dorun(f:text):boolean
 fopen("tmp:dorun.mos",F_OUTPUT)
 writeln(`DOMAKE
model domake
uses 'mmsystem'
parameters
 TODO=""
end-parameters
system(TODO)
exit(getsysstat)
end-model
DOMAKE`)
 fclose(F_OUTPUT)
 if endswith(f,".class") then
  if sysname="windows" then
   todo:=text('java -enableassertions ')+copytext(f,1,f.size-6)
  else
   todo:=text('java -d')+sysarch+" -enableassertions "+copytext(f,1,f.size-6)
  end-if
 else
  todo:='.'+DIRSEP+f
 end-if
 returned:=execmos("rmt:tmp:dorun.mos",text("TODO='")+todo+"'")<>0
end-function

!*************************************************
!* Retrieve the version of a pkg/module or Mosel
!*************************************************
function getpmvers(p:string):integer
 declarations
  line:text
  mp:dynamic array(0..3) of textarea
 end-declarations
 if not exists(pmvers(p)) then
  fopen("null:",F_ERROR) ! in case component cannot be found
  fopen("tmp:vers",F_OUTPUT)
  if p="mosel" then
   system('mosel','exam','-l','en','-dp',env_dsopath,'-H')
  else
   system('mosel','exam','-l','en','-dp',env_dsopath,'-H',p)
  end-if
  fclose(F_OUTPUT)
  fclose(F_ERROR)
  fopen("tmp:vers",F_INPUT)
  if readtextline(line)>10 and regmatch(line,'^[a-zA-Z]* .* version \([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)',1,0,mp) then
   pmvers(p):=parseint(line,mp(1))*1000000+parseint(line,mp(2))*1000+parseint(line,mp(3))
   pmvers_txt(p):=copytext(line,mp(1).start,mp(3).succ-1)
   if findtext(p,".",1)=0 then
    if startswith(line,"Package") then
     pmvers(p+".bim"):=pmvers(p)
    elif startswith(line,"Module") then
     pmvers(p+".dso"):=pmvers(p)
    end-if
   end-if
  else
   pmvers(p):=-1
  end-if
  fclose(F_INPUT)
 end-if
 returned:=pmvers(p)
end-function

!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
declarations
 function checkpackage(scs:array(sf:set of string) of s_srcfile,pkg:text,lsf:list of string,ft:text):boolean
 procedure compcov(sfs:array(sf:set of string) of s_srcfile)
 procedure genreport(srcf:s_srcfile,src:string,covdir:text)
 procedure genlcovinfo(scs:array(sf:set of string) of s_srcfile,covdir:text)
 function addsrcfile(scs:array(string) of s_srcfile,src:string,appzip:text):boolean
 function countlines(f:text):integer
 function findsrc(f:string,appzip:text):text
 function lndx2file(l:integer):integer
 function lndx2line(l:integer):integer
end-declarations

!****************************************************
! Generate a list of directories from parameter
!****************************************************
function build_lstdir(srcpath:string):list of text
 returned:=splittext(srcpath,PATHSEP)
 if returned.size>0 then
  forall(p in returned) do
   p:=expandpath(p)
  end-do
 else
  returned:=[expandpath(".")]
 end-if
end-function

!****************************************************
! Generate srcfiles from parameter
!****************************************************
procedure build_srcfiles(sfs:array(sf:set of string) of s_srcfile,pkgs:list of text)
 declarations
  allpkgs:set of constant text
  lsf:list of string
  ft:text
 end-declarations

 startinstance
 forall(p in pkgs) do
  trim(p)
  if p<>"" and p not in allpkgs and checkpackage(sfs,p,lsf,ft) then
   writeln(" + ",ft," '",p,"' registered ",lsf)
   allpkgs+={p}
  end-if
 end-do
 cleardir(WKDIR,false)
 endinstance(true)

 if sf.size=0 then
  writeln("No package for coverage: aborting")
  exit(3)
 end-if
end-procedure

!****************************************************
!* Save coverage data from mdr on minst
!****************************************************
procedure savecovres(sfs:array(sf:set of string) of s_srcfile)
 declarations
  Rlines:range
  lines:array(Rlines) of integer
  iters:array(Rlines) of integer
  Rfiles:range
  files:array(Rfiles) of string
  Rstarts:range
  starts:array(Rstarts) of integer
 end-declarations

 localsetparam("ioctrl",true)
 nid:=getid(minst)
 initialisations from "bin:rmt:["+nid+"]mcmd:covres@1"
  Rlines lines iters
  Rfiles files
  Rstarts starts
 end-initialisations
 if getparam("iostatus")=0 then
  forall(f in 0..(getlast(Rstarts)-1)|files(f) in sf)
   with srcf=sfs(files(f)) do
    forall(i in starts(f)..(starts(f+1)-1),l=lines(i))
     if l in srcf.rlines and srcf.lincov(l)>=0 then
      srcf.lincov(l)+=iters(i)
     end-if
   end-do
 end-if
end-procedure

!****************************************************
!* Compute and report coverage statistics
!****************************************************
procedure reportcov(sfs:array(sf:set of string) of s_srcfile,covdir:text,mode:integer)
 compcov(sfs)
 localsetparam("realfmt","%.1f")
 writeln("\nGlobal coverage statistics:")
 snbl:=sum(s in sf) sfs(s).nbl
 snblh:=sum(s in sf) sfs(s).nblh
 snbf:=sum(s in sf) sfs(s).nbf
 snbfh:=sum(s in sf) sfs(s).nbfh
 writeln("  lines:    ",snblh*100/snbl,"% (",snblh,"/",snbl,")")
 if snbf>0 then
  writeln("  routines: ",snbfh*100/snbf,"% (",snbfh,"/",snbf,")")
 end-if

 if mode<>0 then
  makedir(covdir)
  writeln("Saving reports in '",covdir,"':")
  if bittest(mode,1)=1 then
   forall(s in sf)
    genreport(sfs(s),s,covdir)
  end-if
  if bittest(mode,2)=2 then
   genlcovinfo(sfs,covdir)
  end-if
 end-if
end-procedure

!****************************************************
! Load a model/package and extract source information
!****************************************************
function checkpackage(sfs:array(sf:set of string) of s_srcfile,pkg:text,lsf:list of string,ft:text):boolean
 declarations
  appzip:text
  path:text
  nbs:integer
  newfiles,oldfiles:set of string

  Rfiles: range
  files:  array(Rfiles) of string
  Rlines: range
  lines:  array(Rlines) of integer

  Rsign: range
  sign:  array(Rsign) of text
  lndx:  array(Rsign) of integer
  name:  array(Rsign) of text
 end-declarations

 reset(lsf)
 ft:="Package"
 nid:=getid(minst)
 forall(pfx in bim_dirs) do
  if endswith(pkg,".zip") then
   path:=expandpath(pfx+DIRSEP+pkg)
   appzip:=path
  else
   path:=expandpath(pfx+DIRSEP+pkg+".bim")
   appzip:=""
  end-if
  if filexists(path) then
   break
  else
   path:=""
  end-if
 end-do
 if path.size>0 then
  localsetparam("ioctrl",true)
  if appzip<>"" then
   cleardir(WKDIR,false)
   bimfile:=expandpath(WKDIR+DIRSEP+expandapp(WKDIR,path))
   load(minst,mdr,bimfile,"l","","","")
  else
   load(minst,mdr,path,"l","","","")
  end-if
  if getparam("iostatus")=0 then
   if findtext(getmodprop(mdr,PROP_SYSCOM),"PKG,",1)<1 then
    ft:=if(appzip="","Model","Application")
   end-if
   initialisations from "bin:rmt:["+nid+"]mcmd:dbglndx@1"
    Rfiles files
    Rlines lines
   end-initialisations
   if getparam("iostatus")=0 and Rfiles.size>0 and 
      findtext(getmodprop(mdr,PROP_SYSCOM),",trace,",1)>0 then
    oldfiles:=sf
    forall(j in Rfiles)
     if endswith(files(j),".mos") and addsrcfile(sfs,files(j),appzip) then
      lsf+=[files(j)]
      nbs+=1
     end-if

    if nbs<1 then
     writeln(" I could not find any valid source file for '",pkg,"'!!!")
    else
     newfiles:=sf-oldfiles
     ! locate effective statements
     forall(i in Rlines,f=lndx2file(lines(i))| files(f) in newfiles)
      with s=sfs(files(f)),l=lndx2line(lines(i)) do
       if l in s.rlines then
        s.lincov(l):=0
	s.nbl+=1
       end-if
      end-do
    
     ! record subroutines names & location
     fopen("null:",F_ERROR) ! may fail if there is no subroutine
     initialisations from "bin:rmt:["+nid+"]mcmd:dbgflndx@1"
      Rsign sign lndx name
     end-initialisations
     fclose(F_ERROR)
     if getparam("iostatus")=0 and Rsign.size>0 then
      forall(i in Rsign, ld=lndx(i), f=lndx2file(lines(ld))|files(f) in newfiles)
       with s=sfs(files(f)),l=lndx2line(lines(ld)) do
        if l in s.rlines then
         s.nbf+=1
         if sign(i)<>"" then
          s.fctnames(s.nbf):=string(name(i)+"("+sign(i)+")")
         else
          s.fctnames(s.nbf):=string(name(i))
         end-if
         s.fctstart(s.nbf):=l
        end-if
       end-do
     end-if
     returned:=true
    end-if
   else
    writeln(" No tracing information found in '",pkg,"'!!!")
   end-if
  else
   writeln(" Failed to load '",path,"'!!!")
  end-if
  unload(mdr)
 else
  writeln(" Package '",pkg,"' not found!!!")
 end-if
end-function

!****************************************************
!* Compute coverage statistics summary
!****************************************************
procedure compcov(sfs:array(sf:set of string) of s_srcfile)
  forall(s in sf,srcf=sfs(s)) do
   srcf.nblh:=0
   forall(i in srcf.rlines)
    if srcf.lincov(i)>0 then srcf.nblh+=1; end-if
   srcf.nbfh:=0
   forall(f in srcf.fctstart.index(1),lc=srcf.lincov(srcf.fctstart(f)))
    if lc>0 then srcf.nbfh+=1; end-if
  end-do
end-procedure

!****************************************************
!* Generate a report for a source file
!****************************************************
procedure genreport(srcf:s_srcfile,src:string,covdir:text)
 declarations
  repfile:text
  l:text
  spc=" "*7
  tsrc:text
 end-declarations

 tsrc:=src
 asproc(regreplace(tsrc,"/","_"))
 asproc(regreplace(tsrc,'\\',"_"))
 asproc(regreplace(tsrc,':',"_"))
 asproc(regreplace(tsrc,';',"_"))
 tsrc+=".cov"
 localsetparam("ioctrl",true)
 repfile:=covdir+DIRSEP+tsrc
 fd:=getfid(F_OUTPUT)
 fopen(repfile,F_OUTPUT)
 if getparam("iostatus")<>0 then
  writeln(" I cannot create the report file '",repfile,"'!!!")
 else
  fopen(srcf.path,F_INPUT)
  if getparam("iostatus")<>0 then
   fwriteln(fd," I cannot find source file '",src,"'!!!")
  else
   if srcf.nbf>0 then
    fwriteln(fd," + '",tsrc+"' (l:",srcf.nblh*100/srcf.nbl,
 				        "%,",srcf.nblh,"/",srcf.nbl,
					" r:",srcf.nbfh*100/srcf.nbf,
 				        "%,",srcf.nbfh,"/",srcf.nbf,")")
   else
    fwriteln(fd," + '",tsrc+"' (l:",srcf.nblh*100/srcf.nbl,
 				        "%,",srcf.nblh,"/",srcf.nbl,")")
   end-if
   forall(i in srcf.rlines)
    if readtextline(l)>0 then
     if srcf.lincov(i)>=0 then
      write(textfmt(srcf.lincov(i),4),"   ",l)
     else
      write(spc,l)
     end-if
    else
     break
    end-if
   localsetparam("realfmt","%.1f")
   writeln("\nCoverage: ")
   writeln("  lines:    ",srcf.nblh*100/srcf.nbl,"% (",srcf.nblh,"/",srcf.nbl,")")
   if srcf.nbf>0 then
    writeln("  routines: ",srcf.nbfh*100/srcf.nbf,"% (",srcf.nbfh,"/",srcf.nbf,")")
   end-if
   fclose(F_INPUT)
  end-if
  fclose(F_OUTPUT)
 end-if
end-procedure

!****************************************************
!* Generate the report as an lcov info file
!****************************************************
procedure genlcovinfo(sfs:array(sf:set of string) of s_srcfile,covdir:text)
 declarations
  repfile:text
  appdir:text
 end-declarations

 fd:=getfid(F_OUTPUT)
 localsetparam("ioctrl",true)
 repfile:=covdir+DIRSEP+"moseltest.info"
 fopen(text("enc:sys+unix,")+repfile,F_OUTPUT)
 if getparam("iostatus")<>0 then
  writeln(" I cannot create the report file '",repfile,"'!!!")
 else
  fwriteln(fd," + 'moseltest.info'")
  writeln("TN:moseltest")
  forall(s in sf,srcf=sfs(s)) do
   if startswith(srcf.path,"zlib.zip:") then
    if appdir="" then
     appdir:=expandpath(covdir+DIRSEP+"appsrc")
     makedir(appdir)
     appdir+=DIRSEP
    end-if
    fname:=appdir+pathsplit(SYS_FNAME,s)
    fcopy(srcf.path,fname)
    writeln("SF:",fname)
   else
    writeln("SF:",srcf.path)
   end-if
   forall(f in srcf.fctstart.index(1))
    writeln("FN:",srcf.fctstart(f),",",srcf.fctnames(f))
   forall(f in srcf.fctstart.index(1),lc=srcf.lincov(srcf.fctstart(f))) do
    writeln("FNDA:",lc,",",srcf.fctnames(f))
   end-do
   writeln("FNF:",srcf.nbf)
   writeln("FNH:",srcf.nbfh)

   forall(i in srcf.rlines,lc=srcf.lincov(i)|lc>=0,nbl as counter) do
    writeln("DA:",i,",",lc)
   end-do
   writeln("LH:",srcf.nblh)
   writeln("LF:",srcf.nbl)
   writeln("end_of_record")
  end-do
  fclose(F_OUTPUT)
  writeln(" To produce a HTML report use the following comand:")
  writeln("  genhtml -o ",covdir,DIRSEP,"html ",covdir,DIRSEP,"moseltest.info")
 end-if
end-procedure

!****************************************************
!* Add a new file to the array of source files
!****************************************************
function addsrcfile(sfs:array(sf:set of string) of s_srcfile,src:string,appzip:text):boolean
 declarations
  path:text
  src2:text
 end-declarations

 if src in sf then
  returned:=true
 else
  path:=findsrc(src,appzip)
  if path="" then
   src2:=pathsplit(SYS_FNAME,src)
   if src2<>src then
    path:=findsrc(string(src2),appzip)
   end-if
  end-if
  if path="" then
   writeln(" Cannot find source file '",src,"'!!!")
  else
   nbl:=countlines(path)
   if nbl<1 then
    writeln(" Source file '",src,"' is empty!!!")
   else
    create(sfs(src))
    with srcf=sfs(src) do
     srcf.path:=path
     srcf.rlines:=1..nbl
     finalise(srcf.rlines)
     srcf.lincov(1):=-1
     srcf.lincov(nbl):=-1
     finalise(srcf.lincov.index(1))
     forall(i in srcf.rlines)
      srcf.lincov(i):=-1
    end-do
    returned:=true
   end-if
  end-if
 end-if
end-function

!****************************************************
!* Try to find a source file
!****************************************************
function findsrc(f:string,appzip:text):text
 declarations
  lsf:list of text
 end-declarations

 if (sysname="windows" and f.size>2 and 
     (startswith(f,'\\') or getchar(f,2)=58)) or
    (sysname<>"windows" and getchar(f,1)=47) then
  if filexists(f) then
   returned:=f
  end-if
 else
  if returned="" and appzip<>"" then
   ! the zip file has been expanded in WKDIR
   findfiles(SYS_RECURS+SYS_NODIR,lsf,WKDIR+DIRSEP+"source",f)
   if lsf.size=1 then
    returned:=text("zlib.zip:"+appzip+",source/"+tc_fixpath(f))
   end-if
  end-if

  if returned="" then
   forall(p in src_dirs) do
    returned:=p+DIRSEP+f
    if filexists(returned) then
     break
    else
     returned:=""
    end-if
   end-do
  end-if
 end-if
end-function

!****************************************************
! Count the number of lines of a file
!****************************************************
function countlines(f:text):integer
 declarations
  l:text
 end-declarations
 localsetparam("ioctrl",true)
 fopen(f,F_INPUT)
 if getparam("iostatus")=0 then
  while(readtextline(l)>0) do
   returned+=1
  end-do
 fclose(F_INPUT)
 else
  returned:=-1
 end-if
end-function

!****************************************************
!* Extract the file number form an lndx
!****************************************************
function lndx2file(l:integer):integer
 declarations
  FILESHIFT=-24
 end-declarations

 returned:=bitshift(l,FILESHIFT)
end-function

!****************************************************
!* Extract the line number from an lndx
!****************************************************
function lndx2line(l:integer):integer
 declarations
  LINEMASK=16777215
 end-declarations

 returned:=bittest(l,LINEMASK)
end-function

!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!*****************************************************
!* Make sure a path uses '/' for directory separation
!*****************************************************
function tc_fixpath(p:text):text
 returned:=p
 asproc(regreplace(returned,'\\','/'))
end-function

!*********************************
!* Quote a text string for TC
!*********************************
procedure tc_quote(t:text)
 asproc(regreplace(t,"[][|']",'|\0'))
 asproc(regreplace(t,"\n","|n"))
 asproc(regreplace(t,"\r",""))      ! from Windows (useless)
end-procedure

!*************************************
!* Generate a TC string from a file
!*************************************
function tc_getfile(f:string):text
 declarations
  l:text
 end-declarations
 fopen(f,F_INPUT)
 while(readtextline(l)>0) do
  tc_quote(l)
  returned+=l
 end-do
 if TCMAXLOG>0 and returned.size>TCMAXLOG then
  sp:=findtext(returned,"|n",returned.size-TCMAXLOG)
  if sp>0 and sp+2<returned.size then
   sp+=2
  else
   sp:=returned.size-TCMAXLOG
  end-if
  deltext(returned,1,sp)
  returned:="...|n"+returned
 end-if
 fclose(F_INPUT)
end-function
end-model
