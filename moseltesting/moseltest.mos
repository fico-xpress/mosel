(!******************************************************
  File moseltest.mos
  ``````````````````
  General Mosel testing framework

  author: Y. Colombani July 2015

  (c) Copyright 2015-2024 Fair Isaac Corporation

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

*******************************************************!)
model moseltest
version 0.7.1
uses 'mmsystem','mmjobs'

parameters
 SRCDIR="alltests"  ! Location of the tests or test file
 TINCL='*'          ! List of file patterns for inclusion
 TEXCL=''           ! List of file patterns for exclusion
 WKDIR="workdir"    ! Temporary directory for cwd
 DATADIR="data"     ! Temporary directory for saving data files
 DSODIR="dso"       ! Temporary dso directory
 LIBPATH=""         ! Paths to additional dso/bim (same syntax as $PATH)
 CONFLINE="!*!"     ! Tag for configuration lines
 ERR="err.txt"      ! Error log file (inside of workdir)
 OUT="out.txt"      ! Output file (inside of workdir)
 BASEREP="report"   ! Report file (after execution, in current directory)
 REPDATED=false     ! Generate unique report file using timestamp
 REPDATEFMT=""      ! Timestamp format for dated report files, eg "%.y%0m%0d%0H%0M%0S"
 REPRESET=true      ! Clear report file (false=>append to existing)
 KEEPDIR=false      ! Keep workdir/dsodir at the end of run
 PIDFILE=""         ! PID file for the xprmsrv server (''=>no xprmsrv)
 REPFILE=""         ! Report file (replaces BASEREP when defined) '-' to disable
 MAXWAIT=60*10      ! Maximum time to wait for an execution
 VALGRIND=false     ! Run tests with valgrind
 KEEPENV=false      ! Keep Mosel related environment variables
 LINELEN=80         ! Length of a line in the report
 RFMT=""            ! Reporting format ("","TC","TAP","TAP13","JUNIT")
 MAXLOGLEN=20000    ! Maximum length of a embedded log file. -1 to disable
 SAVELOGS=false     ! Keep example log even when successful
 SHOWLOGS=false     ! Copy default streams to console when running tests
 LOGDIR=""          ! If defined, create separate log file per test
 TESTPARAMS=""      ! Parameters to pass to the test models
 HAVENMAKE=true     ! Windows: assume nmake is available (use make otherwise)

 COVLST=""          ! List of package/model/app names for coverage (separated by spaces)
 COVSRC=""          ! Paths to package/model sources (default: LIBPATH)
 COVDIR="coverage"  ! Directory where to save coverage reports
 COVREP=0           ! Format of the reports: 1: annotated source files; 2:lcov info file (3:both)
end-parameters

declarations
 DIRSEP=getdirsep
 PATHSEP=getpathsep
 OPTTYPES:array(OPTNAMES:set of string) of string
 Allfiles:list of text
 MOPT:dynamic array(set of string) of text
 minst:Mosel
 mdr:Model
 srcdir:text
 testdir:text
 excludepat=["*.c9"+DIRSEP+"*"]
 pmvers:dynamic array(string) of integer
 pmvers_txt:dynamic array(string) of text
 output_fd:integer

 sysname:string
 sysproc:string
 syshost:string
 sysarch:integer
 sysnaarch:string
 sysnaproc:string
 usenmake:boolean
 repfile:string
 repdate:text
 env_dsodir:text
 env_datadir:text
 env_clspath:text
 env_dsopath:text
 env_bimpfx:text
 TPLEN=LINELEN-22

 s_srcfile=
	record
	  path:text
	  rlines:range
	  nbl,nblh:integer
	  lincov:array(range) of integer
	  nbf,nbfh:integer
	  fctnames:array(range) of string
	  fctstart:array(range) of integer
	end-record
 srcfiles:dynamic array(allsrc:set of string) of s_srcfile
 bim_dirs:list of text
 src_dirs:list of text

 public tfile:text
! System names:
 KNOWNSYSNAMES={"aix","darwin","linux","hp-ux","sunos","windows"}
! A system name may include architecture like aix64/aix32

 rctx:any
 ! Message levels
 MSL_INF=0
 MSL_WAR=1
 MSL_ERR=2

 ! Test status
 TST_TOSTART=-1	! before test starts
 TST_SUCCESS=0
 TST_SKIPPED=1
 TST_ERROR=2	! something went wrong before/after the test
 TST_FAILED=3

 ! test result
 s_tres=
	record
	  label:text
	  num:integer
	  msg:text
	  status:integer
	  time:real
	end-record

 testres:s_tres
 nbfailed:integer

 ! Report format API
 logmsg:procedure(integer,...)
 fatalerror:procedure(integer,text)
 suitestarted:procedure(text,integer)
 suitefinished:procedure
 logtest:procedure(s_tres)

end-declarations

! Prototypes
declarations
 procedure logbeforetest(tres:s_tres,num:integer,fname:text)
 procedure logaftertest(tres:s_tres)
 function processtest(f:text,ft:integer,opts:array(string) of text,tres:s_tres,testdir:text):boolean
 procedure startinstance
 procedure endinstance(discon:boolean)
 function mergeparms(p1:text,p2:text):text
 procedure run_mdr(parms:text,tres:s_tres)
 function execmos(torun:text,parms:text):integer
 function dobuild(tobuild:text):boolean
 function gettotest(path:text,incl:text,excl:text):list of text
 function getfltlist(flt:text): list of string
 procedure cleardir(p:text,rmd:boolean)
 procedure cleardir(p:text,rmd:boolean,keeperr:boolean)
 procedure copydir(src:text,dst:string)
 function findmain(wkdir:text,totest:text):integer
 function findmodel(wkdir:text,mtt:text):text
 function expandapp(wkdir:text,path:text):text
 procedure getopts(f:text,opts:array(set of string) of text)
 procedure defsetenv
 procedure updenv(env:text,spe:set of string)
 function expenv(ev:text):text
 function mkuxpath(p:text):text
 function toskip(opts:array(set of string) of text,tres:s_tres):boolean
 function splicfgline(line:text,val:text):string
 function filexists(f:text):boolean
 function direxists(f:text):boolean
 function findpattern(rpat:text,f:text,rtmsg:text):boolean
 function splitlist(t:text,sc:integer):list of text
 function splitlist(t:text):list of text
 function splitset(t:text):set of string
 procedure savelogs(f:text)
 procedure setsysdep
 function safeload(m:Model,bf:string):boolean
 function safecompile(opts:string,src:string,dst:string):integer
 procedure startxsrv
 procedure stopxsrv
 function domake(f:text):boolean
 function dorun(f:text):boolean
 function getpmvers(p:string):integer
 function logfile2text(f:string):text
 function build_lstdir(srcpath:string):list of text
 procedure build_srcfiles(sfs:array(string) of s_srcfile,pkgs:list of text)
 procedure savecovres(sfs:array(sf:set of string) of s_srcfile)
 procedure reportcov(sfs:array(sf:set of string) of s_srcfile,covdir:text,mode:integer)

 procedure tty_init
 procedure tc_init
 procedure tap_init
 procedure tap13_init
 procedure jut_init
end-declarations

! Known options (types: txt,int,boo,dbl,lst,lns):
! option lst: same as 'txt' but can appear several times (concatenated - sep=' ')
! option lsp: same as 'txt' but can appear several times (concatenated - sep=',')
! option lns: same as 'txt' but can appear several times (concatenated - sep='\n')
 OPTTYPES("runbefore"):="txt"	! model to run before main - exit 2 to skip test
 OPTTYPES("runafter"):="txt"	! model to run after main test
 OPTTYPES("outexpect"):="lns"	! regex to be found in output stream (in order)
 OPTTYPES("errexpect"):="lns"	! regex to be found in error stream (in order)
 OPTTYPES("compstat"):="int"	! expected compilation status (default=0)
 OPTTYPES("componly"):="boo"	! if true: compile only, no execution
 OPTTYPES("runstat"):="int"	! expected run status (default=0)
 OPTTYPES("exitcode"):="int"	! expected exit code (default=0)
 OPTTYPES("restart"):="boo"	! if true: restart instance after this test
 OPTTYPES("newinst"):="boo"	! if true: start a new instance for this test
 OPTTYPES("build"):="lst"	! list of packages/modules to build
 OPTTYPES("package"):="txt"	! =package name => not run, will be saved
 OPTTYPES("module"):="txt"	! =module name => not run, will be saved
 OPTTYPES("copy"):="lst"	! list of files to copy into the working directory
 OPTTYPES("skip"):="boo"	! if true: skip this test
 OPTTYPES("skip_host"):="lst"	! list of host names where test is skipped
 OPTTYPES("skip_sys"):="lst"	! list of system names where test is skipped
 OPTTYPES("only_host"):="lst"	! list of host names where test is run
 OPTTYPES("only_sys"):="lst"	! list of system names where test is run
 OPTTYPES("setenv"):="lns"	! environment variable [sys.]<env>=<value>
 OPTTYPES("noerrmsg"):="boo"	! if true: error stream must be clear after run
 OPTTYPES("parms"):="lsp"	! list of parameters passed to the test model
 OPTTYPES("model"):="txt"	! model to run (valid only in a configuration file)
 OPTTYPES("save"):="lns"	! save specified file for use by another test
 OPTTYPES("restore"):="lns"	! restore specified file from a previous test
 OPTTYPES("required"):="lsp"	! list of packages/modules requited to run the test
 finalise(OPTNAMES)

 output_fd:=getfid(F_OUTPUT)
 case RFMT of
  "": tty_init
  "TC": tc_init
  "TAP","TAP14": tap_init
  "TAP13": tap13_init
  "JUNIT": jut_init
  else
    writeln("Unknown reporting format ",RFMT," - supported formats: TC,TAP,TAP13,JUNIT. Aborting")
    exit(1)
 end-case

! System specific settings
 setsysdep

! Here we go
 srcdir:=SRCDIR
 Allfiles:=gettotest(srcdir,TINCL,TEXCL)
 if Allfiles.size<1 then
  fatalerror(1,"Nothing to test")
 end-if

 makedir(WKDIR)
 cleardir(WKDIR,false)
 makedir(DSODIR)
 cleardir(DSODIR,false)
 makedir(DATADIR)
 cleardir(DATADIR,false)

 env_dsodir:=expandpath(DSODIR)
 env_datadir:=expandpath(DATADIR)
 bim_dirs:=build_lstdir(LIBPATH)
 env_dsopath:=expandpath(WKDIR)+PATHSEP+"."+PATHSEP+jointext(bim_dirs,PATHSEP)+PATHSEP+expandpath(DSODIR)
 env_clspath:=expandpath(getenv("XPRESSDIR")+"/lib/xprm.jar")+PATHSEP+
    expandpath(getenv("XPRESSDIR")+"/lib/xprd.jar")+PATHSEP+
    expandpath(getenv("XPRESSDIR")+"/lib/bindrv.jar")+PATHSEP+'.'
 if KEEPENV then
  env_bimpfx:=getenv("MOSEL_BIM")
  if getenv("MOSEL_DSO")<>"" then
   env_dsopath+=PATHSEP+getenv("MOSEL_DSO")
  end-if
 else
  env_bimpfx:=""
 end-if

 suitestarted(mkuxpath(SRCDIR),Allfiles.size)
 logmsg(MSL_INF,"Moseltest v",getparam("model_version"),"\n",
                "Running Mosel v",pmvers_txt('mosel')," on `",syshost,
                "' (",sysname," ",sysarch,"bit)\n",
                "Tests from: ",SRCDIR,
		if(TINCL<>"" and TINCL<>"*","\nIncluding only: "+TINCL,""),
		if(TEXCL<>"","\nExcluding: "+TEXCL,""))

 if LOGDIR<>"" and not direxists(LOGDIR) then
  makepath(LOGDIR)
  if getsysstat<>0 or not direxists(LOGDIR) then
   fatalerror(1,"Failed to create '"+LOGDIR+"'")
  end-if
 end-if

 if COVLST.size>0 then
  logmsg(MSL_INF,"Coverage mode enabled")
  src_dirs:=build_lstdir(if(COVSRC="",LIBPATH,COVSRC))
  build_srcfiles(srcfiles,splittext(COVLST," "))
  coverage:=true
 end-if

 defsetenv
 startxsrv

 nbfailed:=0
 forall(f in Allfiles,cnt as counter) do
  logbeforetest(testres,cnt,f)
  testres.label:=mkuxpath(f)
  cleardir(WKDIR,false,true)
  testdir:='.'
  if endswith(f,".mos") then
   fcopy(srcdir+'/'+f,WKDIR)
   totest:=pathsplit(SYS_FNAME,f,testdir)
   ftype:=0
  elif endswith(f,".c") then
   fcopy(srcdir+'/'+f,WKDIR)
   totest:=pathsplit(SYS_FNAME,f,testdir)
   ftype:=1
  elif endswith(f,".java") then
   fcopy(srcdir+'/'+f,WKDIR)
   totest:=pathsplit(SYS_FNAME,f,testdir)
   ftype:=2
  elif endswith(f,".tar") then
   untar(srcdir+'/'+f,WKDIR)
   ftype:=findmain(WKDIR,totest)
  elif endswith(f,".tgz") or endswith(f,".tar.gz")then
   untar("zlib.gzip:"+srcdir+'/'+f,WKDIR)
   ftype:=findmain(WKDIR,totest)
  elif endswith(f,".zip") then
   unzip(srcdir+'/'+f,WKDIR)
   ftype:=findmain(WKDIR,totest)
  elif endswith(f,".dir") then
   copydir(srcdir+'/'+f,WKDIR)
   ftype:=findmain(WKDIR,totest)
  elif endswith(f,".mcf") then
   fcopy(srcdir+'/'+f,WKDIR)
   totest:=pathsplit(SYS_FNAME,f,testdir)
   ftype:=3
  else
   testres.status:=TST_ERROR
   testres.msg:="Unexpected file extention"
   logaftertest(testres)
   next
  end-if

  if totest.size>0 then
   getopts(totest,MOPT)
   if ftype=3 then
    totest:=findmodel(WKDIR,MOPT("model"))
   end-if
  end-if

  if totest.size<1 then
   testres.status:=TST_ERROR
   testres.msg:="Main file was not found"
   logaftertest(testres)
   next
  end-if

  if not toskip(MOPT,testres) and 
     (processtest(totest,ftype,MOPT,testres,testdir) or SAVELOGS) then
   savelogs(f)
  end-if

  logaftertest(testres)
 end-do

 disconnect(minst)
 stopxsrv
 if KEEPDIR and Allfiles.size=1 then
  logmsg(MSL_WAR,"Warning: directories '",WKDIR,"', '",DATADIR,"' and '",DSODIR,"' are not deleted")
 else
  cleardir(WKDIR,true)
  cleardir(DSODIR,true)
  cleardir(DATADIR,true)
 end-if

 if SAVELOGS then
  if LOGDIR<>"" then
   logmsg(MSL_INF,"Log files have been saved under '",LOGDIR,"'.")
  elif repfile<>'-' then
   logmsg(MSL_INF,"Log files have been saved in '",repfile,"'.")
  end-if
 end-if

 if coverage then
  reportcov(srcfiles,COVDIR,COVREP)
 end-if

 suitefinished
 exit(if(nbfailed>0,1,0))

!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!***************************
!* Logging before the test
!***************************
procedure logbeforetest(tres:s_tres,num:integer,fname:text)
 reset(tres)
 tres.status:=TST_TOSTART
 tres.num:=num
 tres.label:=mkuxpath(fname)
 logtest(tres)
 fflush
end-procedure

!***************************
!* Logging after the test
!***************************
procedure logaftertest(tres:s_tres)
 if tres.status>=TST_ERROR: nbfailed+=1
 logtest(tres)
 fflush
end-procedure

!******************
!* Process a test
!******************
function processtest(f:text,ft:integer,opts:array(string) of text,tres:s_tres,testdir:text):boolean
 declarations
  specenv:set of string
  rtmsg:text
  datadir:text
 end-declarations

 tres.status:=TST_SUCCESS
 if opts("restore")<>"" then
  forall(fc in splitlist(opts("restore"),10)) do
   fcopy(DATADIR+'/'+fc,WKDIR)
   if getsysstat<>0 then
     tres.msg:="Failed to restore file '"+fc+"'"
     tres.status:=TST_ERROR
     break
   end-if
  end-do
 end-if

 if tres.status=TST_SUCCESS then
  if testdir<>'.' then
   datadir:=srcdir+'/'+testdir
  else
   datadir:=srcdir
  end-if
  if opts("copy")<>"" then
   forall(fc in splitlist(opts("copy"),44)) do
    fcopy(datadir+'/'+fc,WKDIR)
    if getsysstat<>0 then
      tres.msg:="Failed to copy file '"+fc+"'"
      tres.status:=TST_ERROR
      break
    end-if
   end-do
  end-if
 end-if

 if tres.status=TST_SUCCESS then
  updenv(opts("setenv"),specenv)
  if opts("newinst")="true" and specenv.size<1 : endinstance(true)
  startinstance

  rbf:=execmos(opts("runbefore"),"")
  if rbf=2 then
   tres.msg:="because of \"runbefore\""
   tres.status:=TST_SKIPPED
  elif rbf<>0 then
   tres.msg:="Failed to run the 'runbefore' model"
   tres.status:=TST_ERROR
  elif dobuild(opts("build")) then
    tres.msg:="Failed to process the build list ("+opts("build")+")"
    tres.status:=TST_ERROR
  else
   tstart:=gettime
   if ft=0 then					! Mosel file
    bimfile:=string(copytext(f,1,f.size-4)+".bim")
    c:=safecompile(if(coverage,"G","g"),string(f),bimfile)
    expstat:=if(opts("compstat")<>"",parseint(opts("compstat"),1),0)
    if c<>expstat then
     tres.msg:="Compilation failed"
     tres.status:=TST_FAILED
    elif c=0 then
     if opts("componly")<>"true" and opts("package")="" then
      if(safeload(mdr,bimfile)) then
       tres.msg:="Failed to load bimfile"
       tres.status:=TST_ERROR
      else
       if coverage : setcontrol(mdr,"runmode","2")
       run_mdr(mergeparms(TESTPARAMS,opts("parms")),tres)
       if tres.status=TST_SUCCESS then
        expstat:=if(opts("runstat")<>"",parseint(opts("runstat"),1),0)
        expexcde:=if(opts("exitcode")<>"",parseint(opts("exitcode"),1),0)
        if minst.status<>0 or mdr.status<>expstat or mdr.exitcode<>expexcde then
         tres.msg:="Execution error"
         tres.status:=TST_FAILED
        elif coverage then
         savecovres(srcfiles)
        end-if
       ! else timeout
       end-if
       setparam("ioctrl",true)
        unload(mdr)
        asproc(getparam("iostatus"))
       setparam("ioctrl",false)
      end-if
     elif opts("package")<>"" then
      if not endswith(opts("package"),".bim"): opts("package")+=".bim"
      fcopy(WKDIR+"/"+bimfile,DSODIR+"/"+opts("package"))
      if getsysstat<>0 then
        tres.msg:="Failed to save package '"+bimfile+"'"
        tres.status:=TST_ERROR
      end-if
     end-if
    end-if
   elif ft=3 then					! Bim file
    bimfile:=string(f)
    if(safeload(mdr,bimfile)) then
     tres.msg:="Failed to load bimfile"
     tres.status:=TST_ERROR
    else
     if coverage: setcontrol(mdr,"runmode","2")
     run_mdr(mergeparms(TESTPARAMS,opts("parms")),tres)
     if tres.status=TST_SUCCESS then
      expstat:=if(opts("runstat")<>"",parseint(opts("runstat"),1),0)
      expexcde:=if(opts("exitcode")<>"",parseint(opts("exitcode"),1),0)
      if minst.status<>0 or mdr.status<>expstat or mdr.exitcode<>expexcde then
       tres.msg:="Execution error"
       tres.status:=TST_FAILED
      elif coverage then
       savecovres(srcfiles)
      end-if
     ! else timeout
     end-if
     setparam("ioctrl",true)
      unload(mdr)
      asproc(getparam("iostatus"))
     setparam("ioctrl",false)
    end-if
   elif ft=1 then				! C file
    if opts("module")<>"" then
     execfile:=string(copytext(f,1,f.size-2)+".dso")
     if domake(execfile) then
      tres.msg:="Compilation failed"
      tres.status:=TST_ERROR
     else
      fcopy(WKDIR+"/"+execfile,DSODIR+"/"+opts("module"))
      if getsysstat<>0 then
        tres.msg:="Failed to save module '"+execfile+"'"
        tres.status:=TST_ERROR
      end-if
     end-if
    else
     execfile:=string(copytext(f,1,f.size-2)+if(sysname="windows",".exe",""))
     if domake(execfile) then
      tres.msg:="Compilation failed"
      tres.status:=TST_ERROR
     elif dorun(execfile) then
      tres.msg:="Execution error"
      tres.status:=TST_FAILED
     end-if
    end-if
   elif ft=2 then				! Java file
    execfile:=string(copytext(f,1,f.size-5)+".class")
    if domake(execfile) then
     tres.msg:="Compilation failed"
     tres.status:=TST_ERROR
    elif dorun(execfile) then
     tres.msg:="Execution error"
     tres.status:=TST_FAILED
    end-if
   else
    tres.msg:="Unknown file format"
    tres.status:=TST_ERROR
   end-if

   tres.time:=gettime-tstart

   if minst.status<>0 then
    tres.msg:="Mosel crashed"
    if tres.status=TST_SUCCESS: tres.status:=TST_ERROR
   end-if

   if tres.status=TST_SUCCESS and execmos(opts("runafter"),"")<>0 then
    tres.msg:="Failed to run the 'runafter' model"
    tres.status:=TST_ERROR
   end-if

   if tres.status=TST_SUCCESS and opts("save")<>"" then
    forall(fc in splitlist(opts("save"),10)) do
     fcopy(WKDIR+"/"+fc,DATADIR)
     if getsysstat<>0 then
      tres.msg:="Failed to save '"+fc+"'"
      tres.status:=TST_ERROR
      break
     end-if
    end-do
   end-if

   if tres.status=TST_SUCCESS and findpattern(opts("outexpect"),WKDIR+"/"+OUT,rtmsg) then
    tres.msg:=text("Failed to validate 'outexpect' (")+rtmsg+")"
    tres.status:=TST_FAILED
   end-if
   if tres.status=TST_SUCCESS and findpattern(opts("errexpect"),WKDIR+"/"+ERR,rtmsg) then
    tres.msg:=text("Failed to validate 'errexpect' (")+rtmsg+")"
    tres.status:=TST_FAILED
   end-if
   if tres.status=TST_SUCCESS and opts("noerrmsg")="true" and getfsize(WKDIR+"/"+ERR)>0 then
    tres.msg:="Error messages have been displayed"
    tres.status:=TST_FAILED
   end-if
  end-if

  if specenv.size>0 then
   forall(s in specenv)
    setenv(s,"")
   defsetenv             ! Restore defaults
   endinstance(true)
  else
   endinstance(opts("restart")="true")
  end-if

  if tres.status<=TST_SKIPPED and minst.status=-3 then
   tres.msg:="Abnormal instance termination"
   tres.status:=TST_ERROR
  end-if
 end-if
 returned:=tres.status>TST_SKIPPED
end-function

!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!****************************************
!* Prepare the Mosel instance for a run
!****************************************
procedure startinstance
 if minst.status<>0 then
  valgrind:=if(VALGRIND,'valgrind --num-callers=20 ','')
  if connect(minst,'rcmd:'+valgrind+'mosel -r -d "'+expandpath(WKDIR)+
                                   '" -dp "'+env_dsopath+'"')<>0  then
   fatalerror(2,"failed to start Mosel instance")
  end-if
 end-if
 setcontrol(minst,"lang","en")
 outpath:=string(expandpath(text(WKDIR)+"/"+OUT))
 errpath:=string(expandpath(text(WKDIR)+"/"+ERR))
 if SHOWLOGS and RFMT="" then
  outpath:="tee:"+outpath+"&rmt:sysfd:1"
  errpath:="tee:"+errpath+"&rmt:sysfd:2"
 end-if
 setdefstream(minst,F_INPUT,"null:")
 setdefstream(minst,F_OUTPUT+F_LINBUF,outpath)
 setdefstream(minst,F_ERROR+F_LINBUF,errpath)
 fcopy("tmp:makefile",WKDIR+"/makefile")
end-procedure

!**************************************
!* Clean up Mosel instance after a run
!**************************************
procedure endinstance(discon:boolean)
 unload(mdr)
 if discon or minst.status<>0 then
  disconnect(minst)
 else
  setparam("ioctrl",true)
   setdefstream(minst,"null:","","")
   iost:=getparam("iostatus")
  setparam("ioctrl",false)
  if iost<>0 then  ! instance crashed
   disconnect(minst)
  end-if
 end-if
end-procedure

!***********************************
!* Merge 2 parameter lists
!***********************************
function mergeparms(p1:text,p2:text):text
 if p1="" then
  returned:=p2
 elif p2="" then
  returned:=p1
 else
  returned:=p1
  trim(returned)
  tt:=p2
  trim(tt)
  returned+=text(",")+tt
 end-if
end-function

!***********************************
!* Run the model mdr on minst
!***********************************
procedure run_mdr(parms:text,tres:s_tres)
 run(mdr,parms)
 waitfor(EVENT_END,MAXWAIT,WAIT_EXACT)
 if waitexpired then
  tres.msg:=formattext("Timeout (%ds)",MAXWAIT)
  tres.status:=TST_FAILED
  stop(mdr)
  waitfor(EVENT_END,20,WAIT_EXACT)
  if waitexpired then
   kill(minst)
   waitfor(EVENT_END,-1,WAIT_EXACT)
  end-if
 end-if
 dropnextevent
end-procedure

!***********************************
!* Execute a model on the instance
!***********************************
function execmos(torun:text,parms:text):integer
 declarations
  tres:s_tres
 end-declarations
 if torun<>"" then
  if safecompile("g",string(torun),"tmp:bimfile")<>0 or
     safeload(mdr,"tmp:bimfile") then
   returned:=-1
  else
   run_mdr(parms,tres)
   if mdr.status<>0 then
    returned:=-2
   else
    returned:=mdr.exitcode
   end-if
   unload(mdr)
  end-if
 end-if
end-function

!********************************************
!* Build what has to be built before the run
!********************************************
function dobuild(tobuild:text):boolean
 declarations
  lsb:list of text
 end-declarations

 if tobuild<>"" then
  lsb:=splitlist(tobuild)
  forall(td in lsb) do
   if endswith(td,".bim") then
    if safecompile("g",string(copytext(td,1,td.size-4)+".mos"),
                                                string(td))<>0 then
     returned:=true
     break
    end-if
   elif domake(td) then
    returned:=true
    break
   end-if
  end-do
 end-if
end-function

!***************************
!* Get all files to be run
!***************************
function gettotest(path:text,incl:text,excl:text):list of text
 declarations
  f:text
  lsf:list of text
  tincl,texcl:list of string
 end-declarations

 tincl:=getfltlist(incl)
 if tincl.size=0: tincl:=["*"]
 texcl+=getfltlist(excl)+["*.dir"+DIRSEP+"*"]+excludepat

 while (path.size>1 and endswith(path,DIRSEP))
  deltext(path,path.size,path.size)

 if filexists(path) then
  f:=pathsplit(SYS_FNAME,path,path)
  returned:=[f]
 elif endswith(path,".dir") and bittest(getfstat(path), SYS_TYP)=SYS_DIR then
  f:=pathsplit(SYS_FNAME,path,path)
  returned:=[f]
 else
  findfiles(SYS_RECURS+SYS_NODIR,lsf,path,"*.mos|*.c|*.java|*.zip|*.tar|*.tgz|*.tar.gz|*.mcf")
  forall(l in lsf| (or(ff in tincl) pathmatch(l,ff)) and not (or(ff in texcl) pathmatch(l,ff)))
    returned+=[l]
  lsf:=[]
  findfiles(SYS_RECURS+SYS_DIRONLY,lsf,path,"*.dir")
  forall(l in lsf| (or(ff in tincl) pathmatch(l,ff)) and not (or(ff in texcl) pathmatch(l,ff)))
    returned+=[l]
  qsort(SYS_UP,returned)
 end-if
end-function

!***********************************
!* Get an inclusion/exclusion list
!***********************************
function getfltlist(flt:text): list of string
 declarations
  l:text
  repl:string
  lsf:list of text
 end-declarations

 trim(flt)
 if flt<>"" then
  if getchar(flt,1)=getchar("@") then
   if flt="@" then
    fatalerror(1,"Invalid filter specification")
   else
    localsetparam("ioctrl",true)
    fopen(copytext(flt,2,flt.size),F_INPUT)
    if getparam("iostatus")<>0 then
     fatalerror(1,"Filter file not found")
    else
     while(readtextline(l)>0) do
      trim(l)
      fc:=getchar(l,1)
      if fc<>0 and fc<>getchar("#") and fc<>getchar("!"): lsf+=[text(l)]
     end-do
     fclose(F_INPUT)
    end-if
   end-if
  else
   lsf:=splittext(0,flt,",")
  end-if

  repl:=if(sysname="windows","/",'\\')
  dsep:=if(sysname="windows",'\\','/')
  forall(f in lsf) do
   trim(f)
   if f<>"" then
    asproc(regreplace(f,repl,dsep))
    returned+=[string(f)]
   end-if
  end-do
 end-if
end-function

!*********************
!* Clear a directory
!*********************
procedure cleardir(p:text,rmd:boolean)
 cleardir(p,rmd,false)
end-procedure

procedure cleardir(p:text,rmd:boolean,keeperr:boolean)
 declarations
  lsf:list of text
 end-declarations

 if rmd: keeperr:=false

 if minst.status=0 then
  ! If we have built modules, unload them before cleanup
  findfiles(SYS_NODIR+SYS_NOSORT,lsf,p,"*.dso")
  if lsf.size>0 then
   ! 'flushdso' available in Mosel 3.13.1 and newer
   setparam("ioctrl",true)
    setcontrol(minst,"flushdso","")
    asproc(getparam("iostatus"))
   setparam("ioctrl",false)
  end-if

  ! When the instance is running we must keep the error file
  ! otherwise we loose output of the instance (not an issue for the models)
  ! => move it outside of the directory we are clearing
  if keeperr and p=WKDIR and filexists(WKDIR+"/"+ERR) then
   fcopy("null:",WKDIR+"/"+ERR)
   fmove(WKDIR+"/"+ERR,WKDIR+"/../.savederr")
  end-if
 end-if

 ! Firstly remove files only
 removefiles(SYS_RECURS+SYS_NODIR,p,"*")

 if getsysstat<>0 then
  logmsg(MSL_WAR,"Failed to remove files from ",p)
 else
  if sysname="windows" then
   ! Under Windows there may remain dso/exe files still loaded, these will have
   ! been marked for deletion & will be actually deleted once they are unloaded.
   allgone:=false
   forall(i in 0..120) do
    if i>0 then sleep(500); end-if
    lsf:=[]
    findfiles(SYS_RECURS+SYS_NODIR+SYS_NOSORT,lsf,p,"*")
    if getsize(lsf)=0 then allgone:=true; break; end-if
   end-do
   if not allgone then
    logmsg(MSL_WAR,"Unable to remove all files from ",p,", remaining files: ",lsf)
   end-if
  end-if
  ! second round to remove directories
  removefiles(SYS_RECURS,p,"*")
 end-if

 if rmd then
  removedir(p)
 elif filexists(WKDIR+"/../.savederr") then
  ! restore error file
  fmove(WKDIR+"/../.savederr",WKDIR+"/"+ERR)
 end-if
end-procedure

!*************************
!* Copy a directory tree
!*************************
procedure copydir(src:text,dst:string)
 declarations
  lsf:list of text
 end-declarations
 findfiles(SYS_RECURS,lsf,src,"*")
 if lsf.size>0 then
  newtar(0,"tmp:ttar",src,lsf)
  untar("tmp:ttar",dst)
  if getsysstat <> 0 then
   logmsg(MSL_WAR,'Could not copy files from "',src,'" to "',dst,'"!')
  end-if
  fdelete("tmp:ttar")
 end-if
end-procedure

!**************************************
!* Find the "main" file in a directory
!**************************************
function findmain(wkdir:text,totest:text):integer
 declarations
  lsf:list of text
 end-declarations

 totest:=""
 returned:=-1

 findfiles(SYS_NODIR,lsf,wkdir,"main.mos|main.c|Main.java|main.java|main.mcf")
 if lsf.size<>1 then
  lsf:=[]
  findfiles(SYS_NODIR,lsf,wkdir,"*.mos|*.c|*.java|*.mcf")
 end-if

 if lsf.size=1 then
  totest:=lsf.first
  forall(e in [".mos",".c",".java",".mcf"],i as counter)
   if endswith(totest,e) then
    returned:=i-1
    break
   end-if
 end-if
end-function

!******************************************
!* Find the model file of a configuration
!******************************************
function findmodel(wkdir:text,mtt:text):text
 if mtt<>"" then
  if not endswith(mtt,".bim") and not endswith(mtt,".zip") then
   mtt+=".bim"
  end-if
  forall(pfx in bim_dirs) do
   path:=expandpath(pfx+DIRSEP+mtt)
   if filexists(path) then
    if endswith(mtt,".zip") then
     returned:=expandapp(wkdir,path)
    else
     fcopy(path,wkdir)
     returned:=mtt
    end-if
    break
   end-if
  end-do
 end-if
end-function

!***********************************
!* Expand an application zip-file
!***********************************
function expandapp(wkdir:text,path:text):text
 declarations
  lsf:list of text
 end-declarations

 unzip(path,wkdir)
 if getsysstat<>0 then
  logmsg(MSL_WAR,"Failed to extract zip file '",path,"'")
 else
  findfiles(SYS_NODIR,lsf,wkdir,"*.bim")
  if lsf.size=1 then
   returned:=lsf(1)
   reset(lsf)
   findfiles(SYS_NODIR,lsf,wkdir,"model_resources/*")
   forall(f in lsf)
    fcopy(wkdir+DIRSEP+f,wkdir)
  end-if
 end-if
end-function

!***********************************
!* Process options of a source file
!***********************************
procedure getopts(f:text,opts:array(set of string) of text)
 declarations
  line,val:text
  parm:string
 end-declarations

 delcell(opts)
 fopen(WKDIR+"/"+f,F_INPUT)
 while(readtextline(line)>=0) do
  trim(line)
  if startswith(line,CONFLINE) then
   deltext(line,1,CONFLINE.size)
   parm:=splicfgline(line,val)
   if parm in OPTNAMES then
    if val="" then
     delcell(opts(parm))
    elif OPTTYPES(parm)='lst' and opts(parm).size>0 then
     opts(parm)+=' '+val
    elif OPTTYPES(parm)='lsp' and opts(parm).size>0 then
     opts(parm)+=','+val
    elif OPTTYPES(parm)='lns' and opts(parm).size>0 then
     opts(parm)+="\n"+val
    else
     opts(parm):=val
    end-if
   else
    logmsg(MSL_WAR,"   Warning: option `",if(parm.size>0,text(parm),line),
            "' ignored (file ",f,")")
   end-if
  end-if
 end-do
 fclose(F_INPUT)
end-procedure

!************************************
!* Set default environment variables
!************************************
procedure defsetenv
 setenv("DSODIR",env_dsodir)
 setenv("DATADIR",env_datadir)
 setenv("MOSEL_DSO",env_dsopath)   ! For submodels created by worker
 setenv("MOSEL_BIM",env_bimpfx)    ! For submodels created by worker
 setenv("CLASSPATH",env_clspath)
end-procedure

!**********************************
!* Update environment if requested
!**********************************
procedure updenv(env:text,spe:set of string)
 declarations
  mp:array(0..3) of textarea
  lp:list of text
 end-declarations

 lp:=splitlist(env,10)
 forall(e in lp) do
  trim(e)
  if regmatch(e,'^([-a-z0-9]+)\.([A-Za-z0-9_]+) *=(.*)',1,REG_EXTENDED,mp) then
   esys:=copytext(e,mp(1))
   if esys<>sysname and esys<>sysnaarch then
    if endswith(esys,"32") or endswith(esys,"64") then
     deltext(esys,esys.size-1,esys.size)
    end-if
    if string(esys) not in KNOWNSYSNAMES then
     logmsg(MSL_WAR,"Warning: option `setenv ",e,"' ignored (unknown system name)")
    end-if
    next
   else
    ename:=copytext(e,mp(2))
    eval:=copytext(e,mp(3))
   end-if
  elif regmatch(e,'^([A-Za-z0-9_]+) *=(.*)',1,REG_EXTENDED,mp) then
   ename:=copytext(e,mp(1))
   eval:=copytext(e,mp(2))
  else
   logmsg(MSL_WAR,"Warning: option `setenv ",e,"' ignored (syntax error)")
   next
  end-if
  spe+={string(ename)}
  setenv(ename,expenv(eval))
 end-do

 ! If new variables have been defined, restart Mosel instance
 if spe.size>0 then
  endinstance(true)
 end-if
end-procedure

!***************************************
!* Expand ${} for environment variables
!***************************************
function expenv(ev:text):text
 declarations
  mp:array(0..1) of textarea
 end-declarations

 returned:=ev
 while(regmatch(returned,'\${\([A-Za-z_][A-Za-z0-9_]*\)}',1,0,mp)) do
  eval:=getenv(copytext(returned,mp(1)))
  deltext(returned,mp(0))
  if eval.size>0 then
   inserttext(returned,eval,mp(0).start)
  end-if
 end-do
end-function

!*****************************************************
!* Make sure a path uses '/' for directory separation
!*****************************************************
function mkuxpath(p:text):text
 returned:=p
 asproc(regreplace(returned,'\\','/'))
end-function

!*****************************************
!* Check whether a test should be skipped
!*****************************************
function toskip(opts:array(set of string) of text,tres:s_tres):boolean
 declarations
  mp:array(0..3) of textarea
 end-declarations

 if opts("skip")="true" then
  tres.msg:="disabled"
 else
  if opts("skip_host")<>"" then
   lsn:=splitset(opts("skip_host"))
   if syshost in lsn then
    tres.msg:="on this host"
   end-if
  end-if
  if not returned and opts("skip_sys")<>"" then
   lsn:=splitset(opts("skip_sys"))
   if sysname in lsn or sysnaarch in lsn or 
      sysproc in lsn or sysnaproc in lsn then
    tres.msg:="on this system"
   end-if
  end-if
  if not returned and opts("only_host")<>"" then
   lsn:=splitset(opts("only_host"))
   if syshost not in lsn then
    tres.msg:="on this host"
   end-if
  end-if
  if not returned and opts("only_sys")<>"" then
   lsn:=splitset(opts("only_sys"))
   if sysname not in lsn and sysnaarch not in lsn and
      sysproc not in lsn and sysnaproc not in lsn  then
    tres.msg:="on this system"
   end-if
  end-if
  if not returned and opts("required")<>"" then
   forall(p in splittext(opts("required"),","))
    if regmatch(p,' *\([-_.a-zA-Z0-9]*\) *\([<>]\) *\([0-9][0-9.]*\)',1,0,mp) then
     m:=string(copytext(p,mp(1)))
     mv:=copytext(p,mp(3))
     d:=copytext(p,mp(2))
     v:=getpmvers(m)
     if v<0 then
      tres.msg:=text("missing '")+m+"'"
     else
      reset(mp)
      if regmatch(mv,'\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)',1,0,mp) then
       mvn:=parseint(mv,mp(1))*1000000+parseint(mv,mp(2))*1000+parseint(mv,mp(3))
      elif regmatch(mv,'\([0-9]*\)\.\([0-9]*\)',1,0,mp) then
       mvn:=parseint(mv,mp(1))*1000000+parseint(mv,mp(2))*1000
      else
       mvn:=parseint(mv,1)*1000000
      end-if
      if (d=">" and v<mvn) or (d="<" and v>mvn) then
       tres.msg:="incompatible version of '"+m+"' ("+pmvers_txt(m)+d+mv+")"
      end-if
     end-if
    else
     tres.msg:="Malformed 'required' tag '"+p+"' - test ignored"
    end-if
  end-if
 end-if

 if tres.msg.size>0 then
  tres.status:=TST_SKIPPED
  returned:=true
 end-if
end-function

!*******************************************
!* Split a line of the form name |:|= value
!*******************************************
function splicfgline(line:text,val:text):string
 declarations
  mp:array(0..2) of textarea
  dv:real
 end-declarations
 trim(line)
 if regmatch(line,'^\([a-zA-Z0-9_]*\) *[ :=] *\(.*\)',1,0,mp) then
  returned:=string(copytext(line,mp(1)))
  val:=copytext(line,mp(2))
  trim(val)
  if val.size>0 and returned in OPTNAMES then
   case OPTTYPES(returned) of
    'int': do
	 dv:=parseint(val,1)
	 if getparam("sys_endparse")<>val.size+1 or getsysstat<>0 then
	  returned:=""
	 end-if
	end-do
    'boo': do
	 val:=tolower(val)
	 if val<>"true" and val<>"false" then
	  returned:=""
	 end-if
	end-do
    'dbl': do
	 dv:=parsereal(val,1)
	 if getparam("sys_endparse")<>val.size+1 or getsysstat<>0 then
	  returned:=""
	 end-if
	end-do
    ! else: text
   end-case
  end-if
 ! Special case of a Boolean tag (only the name of the tag for 'true')
 elif regmatch(line,'^\([a-zA-Z0-9_]*\)$',1,0,mp) then
  returned:=string(copytext(line,mp(1)))
  if returned in OPTNAMES and OPTTYPES(returned)='boo' then
   val:="true"
  else
   returned:=""
   val:=""
  end-if
 end-if
end-function

!****************************************************
!* Check whether a file exists and is a regular file
!****************************************************
function filexists(f:text):boolean
 fstat:=getfstat(f)
 if fstat<>0 then
  returned:=bittest(fstat,SYS_TYP)=SYS_REG and bittest(fstat,SYS_MOD)>=SYS_READ
 ! else: returned:=false
 end-if
end-function

!****************************************************
!* Check whether a file exists and is a directory
!****************************************************
function direxists(f:text):boolean
 fstat:=getfstat(f)
 if fstat<>0 then
  returned:=bittest(fstat,SYS_TYP)=SYS_DIR and bittest(fstat,SYS_MOD)>=SYS_READ
 ! else: returned:=false
 end-if
end-function

!************************************
!* Look for a pattern in a log file
!************************************
function findpattern(rpat:text,f:text,rtmsg:text):boolean
 declarations
  mp:array(0..0) of textarea
  line:text
  lp:list of text
  cnt:integer
 end-declarations

 if rpat<>"" then
  lp:=splitlist(rpat,10)
  if not filexists(f) then
   returned:=true
   rtmsg:=formattext("#1: %s",lp.first)
  else
   fopen(f,F_INPUT)
   returned:=true
   cnt:=1
   p:=string(lp.first)
   while(readtextline(line)>=0) do
    if regmatch(line,p,1,REG_EXTENDED,mp) then
     cuthead(lp,1)
     if lp.size=0 then
      returned:=false
      break
     else
      p:=string(lp.first)
      cnt+=1
     end-if
    end-if
   end-do
   fclose(F_INPUT)
   rtmsg:=if(returned,formattext("#%d: %s",cnt,lp.first),text(""))
  end-if
 else
  reset(rtmsg)
 end-if
end-function

!****************************************************
!* Split a list of names (with choice of separator)
!****************************************************
function splitlist(t:text,sc:integer):list of text
 declarations
  pctx:parsectx
 end-declarations

 pctx.sepchar:=sc
 if sc=10 then  ! no quoting when splitting full lines
  pctx.qtype:=-1
 end-if
 while(nextfield(t,pctx)) do
  returned+=[parsetext(t,pctx)]
 end-do
end-function

!*************************
!* Split a list of names
!*************************
function splitlist(t:text):list of text
 returned:=splitlist(t,32)
end-function

!************************
!* Split a set of names
!************************
function splitset(t:text):set of string
 declarations
  pctx:parsectx
 end-declarations

 pctx.sepchar:=32  ! ' '
 while(nextfield(t,pctx)) do
  returned+={string(parsetext(t,pctx))}
 end-do
end-function

!******************
!* Save log files
!******************
procedure savelogs(f:text)
 declarations
  lfname: text
 end-declarations
 if LOGDIR="" then
  if repfile<>'-' then
   fopen(repfile,F_OUTPUT+F_APPEND)
   writeln("+"*78)
   writeln(if(f.size<77,"="*(77-f.size),text("=="))," ",f)
   if filexists(WKDIR+"/"+OUT) and getfsize(WKDIR+"/"+OUT)>0 then
    writeln("==== ","output"," ====")
   end-if
   fclose(F_OUTPUT)
   fcopy(WKDIR+"/"+OUT,F_SILENT,repfile,F_APPEND)
   if filexists(WKDIR+"/"+ERR) and getfsize(WKDIR+"/"+ERR)>0 then
    fopen(repfile,F_OUTPUT+F_APPEND)
    writeln("==== ","error"," ====")
    fclose(F_OUTPUT)
    fcopy(WKDIR+"/"+ERR,F_SILENT,repfile,F_APPEND)
   end-if
  end-if
 else
  ff:=copytext(f,1,f.size)
  asproc(regreplace(ff,'([/:\\])',"_",1,REG_EXTENDED))
  if filexists(WKDIR+"/"+OUT) and getfsize(WKDIR+"/"+OUT)>0 then
    lfname:=OUT
    if repdate<>"" then
      asproc(pathsplit(SYS_EXTN,lfname,lfname))
      lfname+=repdate+".txt"
    end-if
    fcopy(WKDIR+"/"+OUT,LOGDIR+"/"+ff+"_"+lfname)
  end-if
  if filexists(WKDIR+"/"+ERR) and getfsize(WKDIR+"/"+ERR)>0 then
    lfname:=ERR
    if repdate<>"" then
      asproc(pathsplit(SYS_EXTN,lfname,lfname))
      lfname+=repdate+".txt"
    end-if
    fcopy(WKDIR+"/"+ERR,LOGDIR+"/"+ff+"_"+lfname)
  end-if
 end-if
end-procedure

!**********************************
!* Prepare system dependent stuff
!**********************************
procedure setsysdep
 sysname:=string(tolower(getsysinfo(SYS_NAME)))
 sysarch:=integer(getsysinfo(SYS_ARCH))
 sysproc:=string(tolower(getsysinfo(SYS_PROC)))
 sysnaarch:=sysname+sysarch
 sysnaproc:=sysname+"-"+sysproc
 syshost:=getsysinfo(SYS_NODE)

 asproc(getpmvers('mosel'))
 pmvers(""):=-1

 if sysname="windows" and HAVENMAKE then
   ! use nmake if it is available
   fopen("null:",F_OUTPUT)
   fopen("null:",F_ERROR)
   system("nmake /nologo /?")
   fclose(F_ERROR)
   fclose(F_OUTPUT)
   usenmake := getsysstat = 0
   if not usenmake then
     logmsg(MSL_WAR,"WARNING: Could not find 'nmake'! Using 'make'.")
   end-if
 end-if

 if REPDATED then
  if REPDATEFMT<>"": localsetparam("datetimefmt",REPDATEFMT)
  repdate:=text("_")+text(datetime(SYS_NOW))
 end-if
 if REPFILE<>"" then
  repfile:=REPFILE
 else
  repfile:=BASEREP+repdate+".txt"
 end-if
 if REPRESET then
  fdelete(repfile)
 end-if
 fopen("tmp:makefile",F_OUTPUT)
 writeln(".SUFFIXES: .bim .mos .dso .java .class")
 if sysname="windows" then
  if sysarch=32 then
   writeln('CFLAGS=/nologo /Zi /MD /I"$(XPRESSDIR)\include"')
  else
   writeln('CFLAGS=/nologo /Zi /MD /GS- /I"$(XPRESSDIR)\include"')
  end-if
  writeln(`WIN32
.c.exe:
	$(CC) $(CFLAGS) $< /link /libpath:"$(XPRESSDIR)\lib" xprm_mc.lib xprm_rt.lib xprd.lib bindrvMD.lib
.c.dso:
	$(CC) $(CFLAGS) /LD $< /Fe$*.dso
.mos.bim:
	mosel compile -g $*.mos
.java.class:
	javac $*.java
WIN32`)
 else				! 32bit Unix
  if sysarch=32 then
   case sysname of
    "linux":writeln(`LIN32
CFLAGS=-m32 -D_REENTRANT -I$(XPRESSDIR)/include
MAKEDSO=$(CC) -m32 -shared
LIN32`)
    "sunos":writeln(`SOL32
CFLAGS=-D_REENTRANT -Kpic -I$(XPRESSDIR)/include
LDFLAGS=-lrt -lsocket -lnsl -lm
MAKEDSO=$(LD) -G
SOL32`)
    "hp-ux":writeln(`HP32
CFLAGS=+Z +DAportable -D_POSIX_C_SOURCE=199506L -I$(XPRESSDIR)/include
LDFLAGS=-lm -Wl,+s
MAKEDSO=$(LD) -b +s
HP32`)
    "aix":writeln(`AIX32
CFLAGS=-q32 -D_THREAD_SAFE -I$(XPRESSDIR)/include
LDFLAGS=-lm -brtl
MAKEDSO=$(CC) -G -q32 -brtl
AIX32`)
   end-case
  else				! 64bit Unix
   case sysname of
    "linux":
	if sysproc="aarch64" then
         writeln(`AARCH64
CFLAGS=-fpic -D_REENTRANT -I$(XPRESSDIR)/include
LDFLAGS=
MAKEDSO=$(CC) -shared
AARCH64`)
	else
         writeln(`LIN64
CFLAGS=-m64 -fpic -D_REENTRANT -I$(XPRESSDIR)/include
LDFLAGS=-fopenmp
MAKEDSO=$(CC) -m64 -shared
LIN64`)
	end-if
    "sunos":writeln(`SOL64
CFLAGS=-m64 -D_REENTRANT -Kpic -I$(XPRESSDIR)/include
LDFLAGS=-lrt -lsocket -lnsl -lm
MAKEDSO=$(LD) -G
SOL64`)
    "hp-ux":writeln(`HP64
CFLAGS=+Z +DD64 -D_POSIX_C_SOURCE=199506L -I$(XPRESSDIR)/include
LDFLAGS=-lm -Wl,+s
MAKEDSO=$(LD) -b +s
HP64`)
    "aix":writeln(`AIX64
CFLAGS=-q64 -D_THREAD_SAFE -I$(XPRESSDIR)/include
LDFLAGS=-lm -brtl
MAKEDSO=$(CC) -G -q64 -brtl
AIX64`)
    "darwin":writeln(`MAC
CFLAGS=-m64 -I$(XPRESSDIR)/include
MAKEDSO=$(CC) -m64 -dynamiclib
MAC`)
   end-case
  end-if
  writeln(`UNX
.c:
	$(CC) $(CFLAGS) $(LDFLAGS) $< -L$(XPRESSDIR)/lib -lxprm_mc -lxprm_rt -lxprd -lbindrv -lpthread -o $*
.c.dso:
	$(CC) -c $(CFLAGS) $<
	$(MAKEDSO) $*.o -o $*.dso
.mos.bim:
	mosel compile -g $*.mos
.java.class:
	javac $*.java
UNX`)
  end-if
  fclose(F_OUTPUT)
end-procedure

!************************************
!* Load a model on 'minst' "safely"
!************************************
function safeload(m:Model,bf:string):boolean
 localsetparam("ioctrl",true)
 load(minst,m,bf)
 returned:= getparam("iostatus")<>0
end-function

!***************************************
!* Compile a model on 'minst' "safely"
!***************************************
function safecompile(opts:string,src:string,dst:string):integer
 localsetparam("ioctrl",true)
 returned:=compile(minst,opts,src,dst)
 asproc(getparam("iostatus"))
end-function

!***************************
!* Start an xprmsrv server
!***************************
procedure startxsrv
 declarations
  inst:Mosel
 end-declarations

 if PIDFILE<>"" then
  fopen("null:",F_ERROR)
  c:=connect(inst,"127.0.0.1")
  fclose(F_ERROR)
  if c=0 then
   disconnect(inst)
   logmsg(MSL_WAR,"Warning: using an existing xprmsrv server - remote tests may fail")
  else
   fopen("tmp:xcfg",F_OUTPUT)
   writeln("XPRMSRV_ACCESS=127.0.0.1 ",getsysinfo(SYS_NODE))
   writeln("[xpress]")
   writeln("MOSEL_CWD=",expandpath(WKDIR))
   fclose(F_OUTPUT)
   system("xprmsrv -tm 3600 -d -pf "+PIDFILE+" "+expandpath("tmp:xcfg"))
   logmsg(MSL_INF,"xprmsrv server started")
  end-if
 end-if
end-procedure

!***************************
!* Stop the xprmsrv server
!***************************
procedure stopxsrv
 if PIDFILE<>"" and filexists(PIDFILE) then
  fcopy(PIDFILE,"text:tfile")
  if sysname="windows" then
  ! Win32: no way to kill a process from a 32bit process on a 64bit system...
   system("tskill "+tfile)
!   system("taskkill /F /PID "+tfile)
   if getsysstat=0 then
    fdelete(PIDFILE)
    logmsg(MSL_INF,"xprmsrv server stopped")
   else
    logmsg(MSL_WAR,"Warning: failed to kill xprmsrv server (pid:",tfile,")")
   end-if
  else
   system("kill "+tfile)
   logmsg(MSL_INF,"xprmsrv server stopped")
  end-if
 end-if
end-procedure

!*****************************************
!* Execute 'make' on the remote instance
!*****************************************
function domake(f:text):boolean
 fopen("tmp:domake.mos",F_OUTPUT)
 writeln(`DOMAKE
model domake
uses 'mmsystem'
parameters
 TODO=""
end-parameters
DOMAKE`)

 if usenmake then
  writeln('system("nmake /nologo "+TODO)')
 else
  writeln('system("make "+TODO)')
 end-if

 writeln(`DOMAKE
exit(getsysstat)
end-model
DOMAKE`)
 fclose(F_OUTPUT)
 returned:=execmos("rmt:tmp:domake.mos",text("TODO=")+f)<>0
end-function

!********************************************
!* Run an executable on the remote instance
!********************************************
function dorun(f:text):boolean
 fopen("tmp:dorun.mos",F_OUTPUT)
 writeln(`DOMAKE
model domake
uses 'mmsystem'
parameters
 TODO=""
end-parameters
system(TODO)
exit(getsysstat)
end-model
DOMAKE`)
 fclose(F_OUTPUT)
 if endswith(f,".class") then
  if sysname="windows" then
   todo:=text('java -enableassertions ')+copytext(f,1,f.size-6)
  else
   todo:=text('java -d')+sysarch+" -enableassertions "+copytext(f,1,f.size-6)
  end-if
 else
  todo:='.'+DIRSEP+f
 end-if
 returned:=execmos("rmt:tmp:dorun.mos",text("TODO='")+todo+"'")<>0
end-function

!*************************************************
!* Retrieve the version of a pkg/module or Mosel
!*************************************************
function getpmvers(p:string):integer
 declarations
  line:text
  mp:dynamic array(0..3) of textarea
 end-declarations
 if not exists(pmvers(p)) then
  fopen("null:",F_ERROR) ! in case component cannot be found
  fopen("tmp:vers",F_OUTPUT)
  if p="mosel" then
   system('mosel','exam','-l','en','-dp',env_dsopath,'-H')
  else
   system('mosel','exam','-l','en','-dp',env_dsopath,'-H',p)
  end-if
  fclose(F_OUTPUT)
  fclose(F_ERROR)
  fopen("tmp:vers",F_INPUT)
  if readtextline(line)>10 and regmatch(line,'^[a-zA-Z]* .* version \([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)',1,0,mp) then
   pmvers(p):=parseint(line,mp(1))*1000000+parseint(line,mp(2))*1000+parseint(line,mp(3))
   pmvers_txt(p):=copytext(line,mp(1).start,mp(3).succ-1)
   if findtext(p,".",1)=0 then
    if startswith(line,"Package") then
     pmvers(p+".bim"):=pmvers(p)
    elif startswith(line,"Module") then
     pmvers(p+".dso"):=pmvers(p)
    end-if
   end-if
  else
   pmvers(p):=-1
  end-if
  fclose(F_INPUT)
 end-if
 returned:=pmvers(p)
end-function

!*************************************
!* Convert a log file to a text
!*************************************
function logfile2text(f:string):text
 fcopy(f,"text:tfile")
 returned:=tfile
 reset(tfile)
 if MAXLOGLEN>0 and returned.size>MAXLOGLEN then
  sp:=findtext(returned,"\n",returned.size-MAXLOGLEN)
  if sp>0 and sp+1<returned.size then
   sp+=1
  else
   sp:=returned.size-MAXLOGLEN
  end-if
  deltext(returned,1,sp)
  returned:="...\n"+returned
 end-if
end-function

!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
declarations
 function checkpackage(scs:array(sf:set of string) of s_srcfile,pkg:text,lsf:list of string,ft:text):boolean
 procedure compcov(sfs:array(sf:set of string) of s_srcfile)
 procedure genreport(srcf:s_srcfile,src:string,covdir:text)
 procedure genlcovinfo(scs:array(sf:set of string) of s_srcfile,covdir:text)
 function addsrcfile(scs:array(string) of s_srcfile,src:string,appzip:text):boolean
 function countlines(f:text):integer
 function findsrc(f:string,appzip:text):text
 function lndx2file(l:integer):integer
 function lndx2line(l:integer):integer
end-declarations

!****************************************************
! Generate a list of directories from parameter
!****************************************************
function build_lstdir(srcpath:string):list of text
 returned:=splittext(srcpath,PATHSEP)
 if returned.size>0 then
  forall(p in returned) do
   p:=expandpath(p)
  end-do
 else
  returned:=[expandpath(".")]
 end-if
end-function

!****************************************************
! Generate srcfiles from parameter
!****************************************************
procedure build_srcfiles(sfs:array(sf:set of string) of s_srcfile,pkgs:list of text)
 declarations
  allpkgs:set of constant text
  lsf:list of string
  ft:text
 end-declarations

 startinstance
 forall(p in pkgs) do
  trim(p)
  if p<>"" and p not in allpkgs and checkpackage(sfs,p,lsf,ft) then
   logmsg(MSL_INF," + ",ft," '",p,"' registered ",lsf)
   allpkgs+={p}
  end-if
 end-do
 cleardir(WKDIR,false)
 endinstance(true)

 if sf.size=0 then
  fatalerror(3,"No package for coverage")
 end-if
end-procedure

!****************************************************
!* Save coverage data from mdr on minst
!****************************************************
procedure savecovres(sfs:array(sf:set of string) of s_srcfile)
 declarations
  Rlines:range
  lines:array(Rlines) of integer
  iters:array(Rlines) of integer
  Rfiles:range
  files:array(Rfiles) of string
  Rstarts:range
  starts:array(Rstarts) of integer
 end-declarations

 localsetparam("ioctrl",true)
 nid:=getid(minst)
 initialisations from "bin:rmt:["+nid+"]mcmd:covres@1"
  Rlines lines iters
  Rfiles files
  Rstarts starts
 end-initialisations
 if getparam("iostatus")=0 then
  forall(f in 0..(getlast(Rstarts)-1)|files(f) in sf)
   with srcf=sfs(files(f)) do
    forall(i in starts(f)..(starts(f+1)-1),l=lines(i))
     if l in srcf.rlines and srcf.lincov(l)>=0 then
      srcf.lincov(l)+=iters(i)
     end-if
   end-do
 end-if
end-procedure

!****************************************************
!* Compute and report coverage statistics
!****************************************************
procedure reportcov(sfs:array(sf:set of string) of s_srcfile,covdir:text,mode:integer)
 compcov(sfs)
 localsetparam("realfmt","%.1f")
 logmsg(MSL_INF,"\nGlobal coverage statistics:")
 snbl:=sum(s in sf) sfs(s).nbl
 snblh:=sum(s in sf) sfs(s).nblh
 snbf:=sum(s in sf) sfs(s).nbf
 snbfh:=sum(s in sf) sfs(s).nbfh
 logmsg(MSL_INF,"  lines:    ",snblh*100/snbl,"% (",snblh,"/",snbl,")")
 if snbf>0 then
  logmsg(MSL_INF,"  routines: ",snbfh*100/snbf,"% (",snbfh,"/",snbf,")")
 end-if

 if mode<>0 then
  makedir(covdir)
  logmsg(MSL_INF,"Saving reports in '",covdir,"':")
  if bittest(mode,1)=1 then
   forall(s in sf)
    genreport(sfs(s),s,covdir)
  end-if
  if bittest(mode,2)=2 then
   genlcovinfo(sfs,covdir)
  end-if
 end-if
end-procedure

!****************************************************
! Load a model/package and extract source information
!****************************************************
function checkpackage(sfs:array(sf:set of string) of s_srcfile,pkg:text,lsf:list of string,ft:text):boolean
 declarations
  appzip:text
  path:text
  nbs:integer
  newfiles,oldfiles:set of string

  Rfiles: range
  files:  array(Rfiles) of string
  Rlines: range
  lines:  array(Rlines) of integer

  Rsign: range
  sign:  array(Rsign) of text
  lndx:  array(Rsign) of integer
  name:  array(Rsign) of text
 end-declarations

 reset(lsf)
 ft:="Package"
 nid:=getid(minst)
 forall(pfx in bim_dirs) do
  if endswith(pkg,".zip") then
   path:=expandpath(pfx+DIRSEP+pkg)
   appzip:=path
  else
   path:=expandpath(pfx+DIRSEP+pkg+".bim")
   appzip:=""
  end-if
  if filexists(path) then
   break
  else
   path:=""
  end-if
 end-do
 if path.size>0 then
  localsetparam("ioctrl",true)
  if appzip<>"" then
   cleardir(WKDIR,false,true)
   bimfile:=expandpath(WKDIR+DIRSEP+expandapp(WKDIR,path))
   load(minst,mdr,bimfile,"l","","","")
  else
   load(minst,mdr,path,"l","","","")
  end-if
  if getparam("iostatus")=0 then
   if findtext(getmodprop(mdr,PROP_SYSCOM),"PKG,",1)<1 then
    ft:=if(appzip="","Model","Application")
   end-if
   initialisations from "bin:rmt:["+nid+"]mcmd:dbglndx@1"
    Rfiles files
    Rlines lines
   end-initialisations
   if getparam("iostatus")=0 and Rfiles.size>0 and 
      findtext(getmodprop(mdr,PROP_SYSCOM),",trace,",1)>0 then
    oldfiles:=sf
    forall(j in Rfiles)
     if endswith(files(j),".mos") and addsrcfile(sfs,files(j),appzip) then
      lsf+=[files(j)]
      nbs+=1
     end-if

    if nbs<1 then
     logmsg(MSL_ERR," I could not find any valid source file for '",pkg,"'!!!")
    else
     newfiles:=sf-oldfiles
     ! locate effective statements
     forall(i in Rlines,f=lndx2file(lines(i))| files(f) in newfiles)
      with s=sfs(files(f)),l=lndx2line(lines(i)) do
       if l in s.rlines then
        s.lincov(l):=0
	s.nbl+=1
       end-if
      end-do
    
     ! record subroutines names & location
     fopen("null:",F_ERROR) ! may fail if there is no subroutine
     initialisations from "bin:rmt:["+nid+"]mcmd:dbgflndx@1"
      Rsign sign lndx name
     end-initialisations
     fclose(F_ERROR)
     if getparam("iostatus")=0 and Rsign.size>0 then
      forall(i in Rsign, ld=lndx(i), f=lndx2file(lines(ld))|files(f) in newfiles)
       with s=sfs(files(f)),l=lndx2line(lines(ld)) do
        if l in s.rlines then
         s.nbf+=1
         if sign(i)<>"" then
          s.fctnames(s.nbf):=string(name(i)+"("+sign(i)+")")
         else
          s.fctnames(s.nbf):=string(name(i))
         end-if
         s.fctstart(s.nbf):=l
        end-if
       end-do
     end-if
     returned:=true
    end-if
   else
    logmsg(MSL_WAR," No tracing information found in '",pkg,"'!!!")
   end-if
  else
   ! display instance errors
   if not SHOWLOGS: fcopy(WKDIR+"/"+ERR,"")
   logmsg(MSL_ERR," Failed to load '",path,"'!!!")
  end-if
  unload(mdr)
 else
  logmsg(MSL_ERR," Package '",pkg,"' not found!!!")
 end-if
end-function

!****************************************************
!* Compute coverage statistics summary
!****************************************************
procedure compcov(sfs:array(sf:set of string) of s_srcfile)
  forall(s in sf,srcf=sfs(s)) do
   srcf.nblh:=0
   forall(i in srcf.rlines)
    if srcf.lincov(i)>0 then srcf.nblh+=1; end-if
   srcf.nbfh:=0
   forall(f in srcf.fctstart.index(1),lc=srcf.lincov(srcf.fctstart(f)))
    if lc>0 then srcf.nbfh+=1; end-if
  end-do
end-procedure

!****************************************************
!* Generate a report for a source file
!****************************************************
procedure genreport(srcf:s_srcfile,src:string,covdir:text)
 declarations
  crepfile:text
  l:text
  spc=" "*7
  tsrc:text
 end-declarations

 tsrc:=src
 asproc(regreplace(tsrc,"/","_"))
 asproc(regreplace(tsrc,'\\',"_"))
 asproc(regreplace(tsrc,':',"_"))
 asproc(regreplace(tsrc,';',"_"))
 tsrc+=".cov"
 localsetparam("ioctrl",true)
 crepfile:=covdir+DIRSEP+tsrc
 fopen(crepfile,F_OUTPUT)
 if getparam("iostatus")<>0 then
  logmsg(MSL_ERR," I cannot create the report file '",crepfile,"'!!!")
 else
  fopen(srcf.path,F_INPUT)
  if getparam("iostatus")<>0 then
   logmsg(MSL_ERR," I cannot find source file '",src,"'!!!")
  else
   if srcf.nbf>0 then
    logmsg(MSL_INF," + '",tsrc+"' (l:",srcf.nblh*100/srcf.nbl,
 				        "%,",srcf.nblh,"/",srcf.nbl,
					" r:",srcf.nbfh*100/srcf.nbf,
 				        "%,",srcf.nbfh,"/",srcf.nbf,")")
   else
    logmsg(MSL_INF," + '",tsrc+"' (l:",srcf.nblh*100/srcf.nbl,
 				        "%,",srcf.nblh,"/",srcf.nbl,")")
   end-if
   forall(i in srcf.rlines)
    if readtextline(l)>0 then
     if srcf.lincov(i)>=0 then
      write(textfmt(srcf.lincov(i),4),"   ",l)
     else
      write(spc,l)
     end-if
    else
     break
    end-if
   localsetparam("realfmt","%.1f")
   writeln("\nCoverage: ")
   writeln("  lines:    ",srcf.nblh*100/srcf.nbl,"% (",srcf.nblh,"/",srcf.nbl,")")
   if srcf.nbf>0 then
    writeln("  routines: ",srcf.nbfh*100/srcf.nbf,"% (",srcf.nbfh,"/",srcf.nbf,")")
   end-if
   fclose(F_INPUT)
  end-if
  fclose(F_OUTPUT)
 end-if
end-procedure

!****************************************************
!* Generate the report as an lcov info file
!****************************************************
procedure genlcovinfo(sfs:array(sf:set of string) of s_srcfile,covdir:text)
 declarations
  crepfile:text
  appdir:text
 end-declarations

 localsetparam("ioctrl",true)
 crepfile:=covdir+DIRSEP+"moseltest.info"
 fopen(text("enc:sys+unix,")+crepfile,F_OUTPUT)
 if getparam("iostatus")<>0 then
  logmsg(MSL_ERR," I cannot create the report file '",crepfile,"'!!!")
 else
  logmsg(MSL_INF," + 'moseltest.info'")
  writeln("TN:moseltest")
  forall(s in sf,srcf=sfs(s)) do
   if startswith(srcf.path,"zlib.zip:") then
    if appdir="" then
     appdir:=expandpath(covdir+DIRSEP+"appsrc")
     makedir(appdir)
     appdir+=DIRSEP
    end-if
    fname:=appdir+pathsplit(SYS_FNAME,s)
    fcopy(srcf.path,fname)
    writeln("SF:",fname)
   else
    writeln("SF:",srcf.path)
   end-if
   forall(f in srcf.fctstart.index(1))
    writeln("FN:",srcf.fctstart(f),",",srcf.fctnames(f))
   forall(f in srcf.fctstart.index(1),lc=srcf.lincov(srcf.fctstart(f))) do
    writeln("FNDA:",lc,",",srcf.fctnames(f))
   end-do
   writeln("FNF:",srcf.nbf)
   writeln("FNH:",srcf.nbfh)

   forall(i in srcf.rlines,lc=srcf.lincov(i)|lc>=0,nbl as counter) do
    writeln("DA:",i,",",lc)
   end-do
   writeln("LH:",srcf.nblh)
   writeln("LF:",srcf.nbl)
   writeln("end_of_record")
  end-do
  fclose(F_OUTPUT)
  logmsg(MSL_INF," To produce a HTML report use the following comand:")
  logmsg(MSL_INF,"  genhtml -o ",covdir,DIRSEP,"html ",covdir,DIRSEP,"moseltest.info")
 end-if
end-procedure

!****************************************************
!* Add a new file to the array of source files
!****************************************************
function addsrcfile(sfs:array(sf:set of string) of s_srcfile,src:string,appzip:text):boolean
 declarations
  path:text
  src2:text
 end-declarations

 if src in sf then
  returned:=true
 else
  path:=findsrc(src,appzip)
  if path="" then
   src2:=pathsplit(SYS_FNAME,src)
   if src2<>src then
    path:=findsrc(string(src2),appzip)
   end-if
  end-if
  if path="" then
   logmsg(MSL_ERR," Cannot find source file '",src,"'!!!")
  else
   nbl:=countlines(path)
   if nbl<1 then
    logmsg(MSL_WAR," Source file '",src,"' is empty!!!")
   else
    create(sfs(src))
    with srcf=sfs(src) do
     srcf.path:=path
     srcf.rlines:=1..nbl
     finalise(srcf.rlines)
     srcf.lincov(1):=-1
     srcf.lincov(nbl):=-1
     finalise(srcf.lincov.index(1))
     forall(i in srcf.rlines)
      srcf.lincov(i):=-1
    end-do
    returned:=true
   end-if
  end-if
 end-if
end-function

!****************************************************
!* Try to find a source file
!****************************************************
function findsrc(f:string,appzip:text):text
 declarations
  lsf:list of text
 end-declarations

 if (sysname="windows" and f.size>2 and 
     (startswith(f,'\\') or getchar(f,2)=58)) or
    (sysname<>"windows" and getchar(f,1)=47) then
  if filexists(f) then
   returned:=f
  end-if
 else
  if returned="" and appzip<>"" then
   ! the zip file has been expanded in WKDIR
   findfiles(SYS_RECURS+SYS_NODIR,lsf,WKDIR+DIRSEP+"source",f)
   if lsf.size=1 then
    returned:=text("zlib.zip:"+appzip+",source/"+mkuxpath(f))
   end-if
  end-if

  if returned="" then
   forall(p in src_dirs) do
    returned:=p+DIRSEP+f
    if filexists(returned) then
     break
    else
     returned:=""
    end-if
   end-do
  end-if
 end-if
end-function

!****************************************************
! Count the number of lines of a file
!****************************************************
function countlines(f:text):integer
 declarations
  l:text
 end-declarations
 localsetparam("ioctrl",true)
 fopen(f,F_INPUT)
 if getparam("iostatus")=0 then
  while(readtextline(l)>0) do
   returned+=1
  end-do
 fclose(F_INPUT)
 else
  returned:=-1
 end-if
end-function

!****************************************************
!* Extract the file number form an lndx
!****************************************************
function lndx2file(l:integer):integer
 declarations
  FILESHIFT=-24
 end-declarations

 returned:=bitshift(l,FILESHIFT)
end-function

!****************************************************
!* Extract the line number from an lndx
!****************************************************
function lndx2line(l:integer):integer
 declarations
  LINEMASK=16777215
 end-declarations

 returned:=bittest(l,LINEMASK)
end-function

!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!********************************* TTY: Default report format (console)
declarations
 tty_ctx=record
 	   sttime:real
           endtestpxf:string
	   nbtests,nbskipped:integer
         end-record
 procedure tty_logmsg(msglev:integer,tolog:...)
 procedure tty_startsuite(tslabel:text,nbtests:integer)
 procedure tty_endsuite
 procedure tty_logtest(tres:s_tres)
 procedure tty_fatalerror(ecode:integer,msg:text)
end-declarations

!*********************************
! TTY: Initialisation
!*********************************
procedure tty_init
 declarations
  ctx:tty_ctx
 end-declarations
 ctx.sttime:=gettime
 if SHOWLOGS: ctx.endtestpxf:="   "
 rctx:=->ctx
 fatalerror:=->tty_fatalerror
 logmsg:=->tty_logmsg
 logtest:=->tty_logtest
 suitestarted:=->tty_startsuite
 suitefinished:=->tty_endsuite
end-procedure

!*********************************
!* TTY: Output a message
!*********************************
procedure tty_logmsg(msglev:integer,tolog:...)
 if tolog.size<1 then
  fwriteln(output_fd)
 elif tolog.size=1 then
  fwriteln(output_fd,tolog(1))
 else
  def_out:=getfid(F_OUTPUT)
  fselect(output_fd)
  forall(i in 1..tolog.size-1)
   write(tolog(i))
  writeln(tolog(tolog.size))
  fselect(def_out)
 end-if
end-procedure

!*********************************
! TTY: Start test suite
!*********************************
procedure tty_startsuite(tslabel:text,nbtests:integer)
 rctx.tty_ctx.nbtests:=nbtests
end-procedure

!*********************************
! TTY: End test suite
!*********************************
procedure tty_endsuite
 return
end-procedure

!*********************************
! TTY: Logging before/after test
!*********************************
procedure tty_logtest(tres:s_tres)
 with ctx=rctx.tty_ctx do
  if tres.status=TST_TOSTART then	! Test starting
   if tres.num=1then
    writeln("-- Starting testing procedure --")
    ctx.sttime:=gettime
   end-if
   write(" + ",tres.label,": ")
   if SHOWLOGS then
    writeln
   else
    if tres.label.size+3+2<TPLEN then
     write(" "*(TPLEN-3-2-tres.label.size))
    end-if
    fflush
   end-if
  else					! Test finished
   if tres.status=TST_SKIPPED then
    writeln(ctx.endtestpxf,"Skipped (",testres.msg,")")
    ctx.nbskipped+=1
   elif tres.status<>TST_SUCCESS then
    writeln(ctx.endtestpxf,testres.msg,"!!!")
   else
    writeln(ctx.endtestpxf,formattext("Done in %.3fs",testres.time))
   end-if
   if tres.num=ctx.nbtests then		! Last test finished: show report
    writeln("-- End of testing procedure --")
    writeln("Total time: ",formattext("%.3fs",gettime-ctx.sttime))
    if ctx.nbskipped=ctx.nbtests then
     writeln("No test run over ",ctx.nbtests)
    elif ctx.nbtests-ctx.nbskipped>1 then
     writeln(ctx.nbtests-ctx.nbskipped," tests were run over a total of ",ctx.nbtests)
    else
     writeln(1," test was run over a total of ",ctx.nbtests)
    end-if
    if nbfailed>0 then
     write(nbfailed," ",if(nbfailed>1,"tests","test")," failed. ")
     if LOGDIR<>"" then
      writeln("See log files under '",LOGDIR,"' for further details.")
     elif repfile<>'-' then
      writeln("See '",repfile,"' for further details.")
     else
      writeln
     end-if
    end-if
   end-if
  end-if
 end-do
end-procedure

!*********************************
! TTY: Fatal error and exit
!*********************************
procedure tty_fatalerror(ecode:integer,msg:text)
 tty_logmsg(MSL_ERR,"Fatal error: "+msg+"! Aborting.")
 exit(ecode)
end-procedure

!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!********************************* TC: Teamcity message service
declarations
 tc_ctx=record
         tclabel:text
	 tslabel:text
        end-record
 procedure tc_logmsg(msglev:integer,tolog:...)
 procedure tc_startsuite(tslabel:text,nbtests:integer)
 procedure tc_endsuite
 procedure tc_logtest(tres:s_tres)
 procedure tc_fatalerror(ecode:integer,msg:text)
 procedure tc_quote(t:text)
 function tc_getfile(f:string):text
 procedure tc_savelogs(tcl:text)
end-declarations

!*********************************
! TC: Initialisation
!*********************************
procedure tc_init
 declarations
  ctx:tc_ctx
 end-declarations
 rctx:=->ctx
 logtest:=->tc_logtest
 logmsg:=->tc_logmsg
 fatalerror:=->tc_fatalerror
 suitestarted:=->tc_startsuite
 suitefinished:=->tc_endsuite
end-procedure

!*********************************
!* TC: Output a message
!*********************************
procedure tc_logmsg(msglev:integer,tolog:...)
 declarations
  msg:text
  stat:string
 end-declarations

 if tolog.size>0 then
  msg:=text(tolog(1))
  forall(i in 2..tolog.size)
   msg+=text(tolog(i))
  tc_quote(msg)
  case msglev of
   MSL_INF: stat:="NORMAL"
   MSL_WAR: stat:="WARNING"
   else     stat:="ERROR"
  end-case
  fwriteln(output_fd,"##teamcity[message text='",msg,"' status='",stat,"']")
 end-if
end-procedure

!*********************************
! TC: Start test suite
!*********************************
procedure tc_startsuite(tslabel:text,nbtests:integer)
 localsetparam("datetimefmt","%.y-%0m-%0dT%0H:%0M:%0S%0F")
 rctx.tc_ctx.tslabel:="moseltest-"+tslabel
 writeln("##teamcity[testSuiteStarted name='",rctx.tc_ctx.tslabel,"' timestamp='",datetime(SYS_NOW),"']")
end-procedure

!*********************************
! TC: End test suite
!*********************************
procedure tc_endsuite
 localsetparam("datetimefmt","%.y-%0m-%0dT%0H:%0M:%0S%0F")
 writeln("##teamcity[testSuiteFinished name='",rctx.tc_ctx.tslabel,"' timestamp='",datetime(SYS_NOW),"']")
 rctx.tc_ctx.tslabel:=""
end-procedure

!*********************************
! TC: Logging before/after test
!*********************************
procedure tc_logtest(tres:s_tres)
 if tres.status=TST_TOSTART then	! Test starting
   rctx.tc_ctx.tclabel:=text("name='")+tres.label+"'"
   writeln("##teamcity[testStarted ",rctx.tc_ctx.tclabel,"]")
 else					! Test finished
  tc_quote(testres.msg)
  if tres.status=TST_SKIPPED then
    writeln("##teamcity[testIgnored ",rctx.tc_ctx.tclabel," message='",testres.msg,"']")
  elif tres.status<>TST_SUCCESS then
    writeln("##teamcity[testFailed ",rctx.tc_ctx.tclabel," message='",testres.msg,"']")
  end-if
  if SAVELOGS or tres.status>=TST_ERROR: tc_savelogs(rctx.tc_ctx.tclabel)
  writeln("##teamcity[testFinished ",rctx.tc_ctx.tclabel,formattext(" duration='%.0f'",testres.time*1000),"]")
  rctx.tc_ctx.tclabel:=""
 end-if
end-procedure

!*********************************
! TC: Fatal error and exit
!*********************************
procedure tc_fatalerror(ecode:integer,msg:text)
 if rctx.tc_ctx.tslabel<>"" then
  if rctx.tc_ctx.tclabel<>"" then
   tc_logtest(s_tres(.status:=TST_ERROR,.msg:="aborting"))
  end-if
  tc_endsuite
 end-if
 tc_logmsg(MSL_ERR,"Fatal error: "+msg+"! Aborting.")
 exit(ecode)
end-procedure

!*********************************
!* Quote a text string for TC
!*********************************
procedure tc_quote(t:text)
 asproc(regreplace(t,"[][|']",'|\0'))
 asproc(regreplace(t,"\n","|n"))
 asproc(regreplace(t,"\r",""))      ! from Windows (useless)
end-procedure

!*************************************
!* Generate a TC string from a file
!*************************************
function tc_getfile(f:string):text
 returned:=logfile2text(f)
 tc_quote(returned)
end-function

!*******************
! Save logs for TC
!*******************
procedure tc_savelogs(tcl:text)
 if MAXLOGLEN>=0 then
  if filexists(WKDIR+"/"+OUT) and getfsize(WKDIR+"/"+OUT)>0 then
   writeln("##teamcity[testStdOut ",tcl," out='",tc_getfile(WKDIR+"/"+OUT),"']")
  end-if
  if filexists(WKDIR+"/"+ERR) and getfsize(WKDIR+"/"+ERR)>0 then
   writeln("##teamcity[testStdErr ",tcl," out='",tc_getfile(WKDIR+"/"+ERR),"']")
  end-if
 end-if
end-procedure

!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!********************************* TAP: Test Anything Protocol
declarations
 procedure tap_logmsg(msglev:integer,tolog:...)
 procedure tap_startsuite(tslabel:text,nbtests:integer)
 procedure tap_endsuite
 procedure tap_logtest(tres:s_tres)
 procedure tap_fatalerror(ecode:integer,msg:text)
 function tap_quote(t:text):text
 procedure tap_file2yaml(f:string,label:string)
 procedure tap_savelogs(num:integer)
end-declarations

!*********************************
! TC: Initialisation
!*********************************
procedure tap_init
 if rctx is not integer: rctx:=14
 writeln("TAP version ",rctx)
 logtest:=->tap_logtest
 logmsg:=->tap_logmsg
 fatalerror:=->tap_fatalerror
 suitestarted:=->tap_startsuite
 suitefinished:=->tap_endsuite
end-procedure

procedure tap13_init
 rctx:=13
 tap_init
end-procedure

!*************************************
!* TAP: Output a message as a comment
!*************************************
procedure tap_logmsg(msglev:integer,tolog:...)
 declarations
  msg:text
  lsm:list of text
 end-declarations

 if tolog.size>0 then
  msg:=text(tolog(1))
  forall(i in 2..tolog.size)
   msg+=text(tolog(i))
  lsm:=splittext(-1,msg,"\n")
  forall(m in lsm) do
   trim(m,SYS_RIGHT)
   writeln("# ",m)
  end-do
 end-if
end-procedure

!*********************************
! TAP: Start test suite
!*********************************
procedure tap_startsuite(tslabel:text,nbtests:integer)
 localsetparam("datetimefmt","%.y-%0m-%0dT%0H:%0M:%0S")
 writeln("# Started ",datetime(SYS_NOW))
 writeln("1..",nbtests)
end-procedure

!*********************************
! TAP: End test suite
!*********************************
procedure tap_endsuite
 localsetparam("datetimefmt","%.y-%0m-%0dT%0H:%0M:%0S")
 writeln("# Finished ",datetime(SYS_NOW))
end-procedure

!*********************************
! TAP: Logging before/after test
!*********************************
procedure tap_logtest(tres:s_tres)
 if tres.status<>TST_TOSTART then	! Test starting
  dsep:=if(rctx.integer=14," - "," ")
  if tres.status=TST_SKIPPED then
    writeln("ok ",tres.num,dsep,tap_quote(tres.label)," # SKIP ",tap_quote(testres.msg))
  else
   if tres.status<>TST_SUCCESS then
    writeln("not ok ",tres.num,dsep,tap_quote(tres.label))
   else
    writeln("ok ",tres.num,dsep,tap_quote(tres.label))
   end-if
   writeln("  ---")
   writeln(formattext("  duration_ms: %.0f",testres.time*1000))
   if testres.msg<>'' : writeln("  message: ",quote(testres.msg,0,0))
   if SAVELOGS or tres.status>=TST_ERROR: tap_savelogs(tres.num)
   writeln("  ...")
  end-if
 end-if
end-procedure

!*********************************
! TAP: Fatal error and exit
!*********************************
procedure tap_fatalerror(ecode:integer,msg:text)
 writeln("Bail out! ",tap_quote(msg))
 exit(ecode)
end-procedure

!******************************
!* Quote a text string for TAP
!******************************
function tap_quote(t:text):text
 returned:=t
 if rctx.integer>=14 : asproc(regreplace(returned,'[#\\]','\\\0'))
 asproc(regreplace(returned,"\r",""))      ! from Windows (useless)
end-function

!****************************************************
!* Copy a file to the TAP stream as a YAML inclusion
!****************************************************
procedure tap_file2yaml(f:string,label:string)
 declarations
  l:text
 end-declarations
 writeln("    ",label,":")
 writeln("     File-Size: ",getfsize(f))
 writeln("     File-Name: ",label)
 writeln("     File-Type: text/plain")
(! Using a single line for base64 encoding
 fcopy(f,"mmssl.base64:nonl,text:tfile")
 writeln("     File-Content: ",tfile)
 reset(tfile)
!)
! Using multi-line base64
 writeln("     File-Content: |")
 fcopy(f,"mmssl.base64:tmp:b64")
 fopen("tmp:b64",F_INPUT)
 while(readtextline(l)>0) do
  write("      ",l)
 end-do
 fclose(F_INPUT)
 fdelete("tmp:b64")
end-procedure

!*******************
! Save logs for TAP
!*******************
procedure tap_savelogs(num:integer)
 if MAXLOGLEN>=0 then
  headprinted:=false
  if filexists(WKDIR+"/"+OUT) and getfsize(WKDIR+"/"+OUT)>0 then
   writeln("  extensions:\n   Files:")
   headprinted:=true
   tap_file2yaml(WKDIR+"/"+OUT,"out_"+num+".txt")
  end-if
  if filexists(WKDIR+"/"+ERR) and getfsize(WKDIR+"/"+ERR)>0 then
   if not headprinted then
    writeln("  extensions:\n   Files:")
    headprinted:=true
   end-if
   tap_file2yaml(WKDIR+"/"+ERR,"err_"+num+".txt")
  end-if
 end-if
end-procedure

!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!********************************* JUNIT: Teamcity message service
declarations
 jut_ctx=record
         tclabel:text
	 tslabel:text
	 logs:text
        end-record
 procedure jut_logmsg(msglev:integer,tolog:...)
 procedure jut_startsuite(tslabel:text,nbtests:integer)
 procedure jut_endsuite
 procedure jut_logtest(tres:s_tres)
 procedure jut_fatalerror(ecode:integer,msg:text)
 procedure jut_quote(t:text)
 function jut_getfile(f:string):text
 procedure jut_savelogs
end-declarations

!*********************************
! JUNIT: Initialisation
!*********************************
procedure jut_init
 declarations
  ctx:jut_ctx
 end-declarations
 rctx:=->ctx
 logtest:=->jut_logtest
 logmsg:=->jut_logmsg
 fatalerror:=->jut_fatalerror
 suitestarted:=->jut_startsuite
 suitefinished:=->jut_endsuite
end-procedure

!*********************************
!* JUNIT: Output a message
!*********************************
procedure jut_logmsg(msglev:integer,tolog:...)
 forall(m in tolog)
  rctx.jut_ctx.logs+=text(m)
end-procedure

!*********************************
! JUNIT: Start test suite
!*********************************
procedure jut_startsuite(tslabel:text,nbtests:integer)
 rctx.jut_ctx.tslabel:="moseltest-"+tslabel
 jut_quote(rctx.jut_ctx.tslabel)
 localsetparam("datetimefmt","%.y-%0m-%0dT%0H:%0M:%0S")
 writeln('<?xml version="1.0" encoding="UTF-8"?>')
 writeln("<testsuites>")
 writeln(' <testsuite name="',rctx.jut_ctx.tslabel,
         '" tests="',nbtests,
         '" timestamp="',datetime(SYS_NOW),'">')
end-procedure

!*********************************
! JUNIT: End test suite
!*********************************
procedure jut_endsuite
 localsetparam("datetimefmt","%.y-%0m-%0dT%0H:%0M:%0S")
 if rctx.jut_ctx.logs.size>0 then
  jut_quote(rctx.jut_ctx.logs)
  write("  <system-out>\n",rctx.jut_ctx.logs)
  if endswith(rctx.jut_ctx.logs,"\n") then
   writeln("  </system-out>")
  else
   writeln("\n  </system-out>")
  end-if
 end-if
 writeln(" </testsuite>\n</testsuites>")
 rctx.jut_ctx.tslabel:=""
end-procedure

!*********************************
! JUNIT: Logging before/after test
!*********************************
procedure jut_logtest(tres:s_tres)
 if tres.status=TST_TOSTART then	! Test starting
   rctx.jut_ctx.tclabel:=tres.label
   jut_quote(rctx.jut_ctx.tclabel)
 else					! Test finished
  jut_quote(testres.msg)
  write('  <testcase name="',rctx.jut_ctx.tclabel,'" calssname="',rctx.jut_ctx.tslabel,'" time="',formattext("%.3f",tres.time),'"')
  if tres.status=TST_SKIPPED then
    writeln(">\n    <skipped message=\"",testres.msg,'"/>')
  elif tres.status=TST_ERROR then
    writeln(">\n    <error message=\"",testres.msg,'"/>')
  elif tres.status<>TST_SUCCESS then
    writeln(">\n    <failure message=\"",testres.msg,'"/>')
  elif not SAVELOGS then
    writeln('/>')
  end-if
  if SAVELOGS or tres.status>=TST_ERROR: jut_savelogs
  if tres.status<>TST_SUCCESS or SAVELOGS then
   writeln('  </testcase>')
  end-if
  rctx.jut_ctx.tclabel:=""
 end-if
end-procedure

!*********************************
! JUNIT: Fatal error and exit
!*********************************
procedure jut_fatalerror(ecode:integer,msg:text)
 if rctx.jut_ctx.tslabel<>"" then
  if rctx.jut_ctx.tclabel<>"" then
   jut_logtest(s_tres(.status:=TST_ERROR,.msg:="aborting"))
  end-if
  jut_logmsg(MSL_ERR,"Fatal error: "+msg+"! Aborting.")
  jut_endsuite
 else
  fwriteln(2,"Fatal error: "+msg+"! Aborting.")
 end-if
 exit(ecode)
end-procedure

!*********************************
!* Quote a text string for JUNIT
!*********************************
procedure jut_quote(t:text)
 asproc(regreplace(t,'\&','&amp;'))
 asproc(regreplace(t,"'",'&apos;'))
 asproc(regreplace(t,">",'&gt;'))
 asproc(regreplace(t,"<",'&lt;'))
 asproc(regreplace(t,'"','&quot;'))
 asproc(regreplace(t,"\r",""))      ! from Windows (useless)
end-procedure

!*************************************
!* Generate a JUNIT string from a file
!*************************************
function jut_getfile(f:string):text
 returned:=logfile2text(f)
 jut_quote(returned)
 if not endswith(returned,"\n"): returned+="\n"
end-function

!*******************
! Save logs for JUNIT
!*******************
procedure jut_savelogs
 if MAXLOGLEN>=0 then
  if filexists(WKDIR+"/"+OUT) and getfsize(WKDIR+"/"+OUT)>0 then
   writeln("    <system-out>\n",jut_getfile(WKDIR+"/"+OUT),"    </system-out>")
  end-if
  if filexists(WKDIR+"/"+ERR) and getfsize(WKDIR+"/"+ERR)>0 then
   writeln("    <system-err>\n",jut_getfile(WKDIR+"/"+ERR),"    </system-err>")
  end-if
 end-if
end-procedure

end-model
