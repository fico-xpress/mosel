(!******************************************************
   Mosel jobqueue Package
   ====================== 

   file jqsched.mos 
   ````````````````
   Submodel started by the 'jobqueue' package
   - Management of the task queues. This submodel is terminated when 
     the last queue is deleted, otherwise it remains active until the 
     model using the 'jobqueue' package terminates its execution.
   - For each worker, this model starts an instance of the controler
     model (jqctrl.mos).
   - Declarations that are shared with the controler are defined
     in package 'jqcommon'.
 
   author: Y. Colombani, Feb. 2019

   (c) Copyright 2019 Fair Isaac Corporation
  
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
       http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

*******************************************************!)
model jqsched
uses 'mmjobs'
imports 'jqcommon'
nssearch jsched

parameters
 JQID=""                        ! Unique ID generated by jobqueue to avoid clashes
 COMPFLG=""                     ! Compilation options for controler model:
                                ! "" for production,  "G" for debugging
end-parameters

! Internal data structures
declarations
 allnds:range                   ! Set of Mosel instances
 allwks:range                   ! Set of threads (possibly several per node)
 qnode=record                   ! Node (= local or remote Mosel instance)
        cstr:text
	info:string
	banner:string
	mi:Mosel
	wids:range
	disabled:boolean
       end-record
 worker=record                  ! Worker (= thread within a Mosel instance) 
          nid:integer
	  mo:Model
	  tid:integer
        end-record
 queue=record                   ! Queue (= computation tasks and workers)
        nbwk:integer
	nbdisabled:integer
	lastused:integer
        nodes:dynamic array(allnds) of qnode
	workers:dynamic array(allwks) of worker
	mytasks:list of integer
       end-record
 queues:hashmap array(Q:range) of queue

 qtask=record                   ! Computation task
        status:integer
        job:jq_job
	rtparms:text
        qid:integer
        wid:integer
	nbexec:integer
       end-record
 tasks:hashmap array(T:range) of qtask
 
 finished:boolean
 maxtime:real
 jqverb:integer
 jqctrl_src_gz: string
end-declarations

! Scheduler commands and their implementations
declarations
  procedure cmd_newqueue
  procedure cmd_delqueue(qid:integer)
  procedure cmd_newnode(qid:integer)
  procedure cmd_newtask(qid:integer)
  procedure cmd_getpending(qid:integer)
  procedure cmd_queueflush(qid:integer)
  procedure cmd_queuereset(qid:integer)
  procedure cmd_taskfrque(qid:integer)
  procedure cmd_taskcancel(tid:integer)
  procedure cmd_taskrest(tid:integer)
  procedure cmd_queueinfo(qid:integer)

  procedure task_free(tid:integer)
  procedure queue_flush(qid:integer)
  function queue_reset(qid:integer):integer
  function task_frque(qid:integer):integer
  function getpending(qid:integer):integer
  procedure settaskstat(tid:integer,status:integer,msg:text)
  function processend(evt:Event):integer
  procedure ctrl_cleanup(mo:Model,tid:integer)
  procedure updatequeue(qid:integer)
  function runqueue(qid:integer):boolean

  procedure disablenode(qid:integer,nid:integer)
  function nodeready(qid:integer,nid:integer):boolean
  function findworker(qid:integer):integer
  function isqueueidle(qid:integer):boolean
end-declarations

!---------------------------------------------------------
! Create a new queue
procedure cmd_newqueue
 if queues.size=Q.size then
  qid:=Q.size+1
 else
  forall(t in 1..Q.size|not exists(queues(t))) do
   qid:=t
   break
  end-do
 end-if
 create(queues(qid))
 if jqverb>1 then logmsg(formattext("New queue %d",qid)); end-if
 send(CMD_OK,qid)
end-procedure

! Delete a queue
procedure cmd_delqueue(qid:integer)
 if not exists(queues(qid)) then
  logmsg(formattext("Invalid queue ID %d",qid))
  send(CMD_ERR,0)
 elif isqueueidle(qid) and task_frque(qid)=0 and queue_reset(qid)=0 then
  if jqverb>1 then logmsg(formattext("Deleting queue %d",qid)); end-if
  delcell(queues(qid))
  send(CMD_OK,0)
 else
  send(CMD_OK,1)
 end-if
end-procedure

! Add a node to a queue
procedure cmd_newnode(qid:integer)
 declarations
  cstr:text
  mt:integer
 end-declarations

 if not exists(queues(qid)) then
  logmsg(formattext("Invalid queue ID %d",qid))
  send(CMD_ERR,0)
 else
  initialisations from msgfile
   cstr mt
  end-initialisations

  if mt<1 then
   logmsg("Minimum thread per node is 1")
   send(CMD_ERR,0)
  else
   with q=queues(qid) do
    nid:=q.nodes.size+1
    create(q.nodes(nid))
    q.nodes(nid).cstr:=cstr
    wid:=q.workers.size+1
    q.nodes(nid).wids:=wid..(wid+mt-1)
    finalise(q.nodes(nid).wids)
    forall(w in q.nodes(nid).wids) do
     create(q.workers(w))
     q.workers(w).nid:=nid
    end-do
    q.nbwk+=mt
    if jqverb>1 then logmsg(formattext("New node %d/%d(%s) [%d..%d]",qid,nid,cstr,q.nodes(nid).wids.first,q.nodes(nid).wids.last)); end-if
   end-do
   send(CMD_OK,nid)
  end-if
 end-if
end-procedure

! Add a task to a queue
procedure cmd_newtask(qid:integer)
 declarations
  j:jq_job
  rtp:text
 end-declarations

 if not exists(queues(qid)) then
  logmsg(formattext("Invalid queue ID %d",qid))
  send(CMD_ERR,0)
 else
  initialisations from msgfile
   j rtp
  end-initialisations

  if tasks.size=T.size then
   tid:=T.size+1
  else
   forall(t in 1..T.size|not exists(tasks(t))) do
    tid:=t
    break
   end-do
  end-if
  create(tasks(tid))
  with t=tasks(tid) do
   t.qid:=qid
   t.job:=j
   t.rtparms:=rtp
   queues(qid).mytasks+=[tid]
  end-do
  fopen(taskoutfile(tid),F_OUTPUT); fclose(F_OUTPUT)
  fopen(taskerrfile(tid),F_OUTPUT); fclose(F_OUTPUT)
  if j.resultfile<>"" then
   fopen(taskresfile(tid),F_OUTPUT); fclose(F_OUTPUT)
  end-if
  settaskstat(tid,RT_PENDING,"")
  if jqverb>1 then logmsg(formattext("New task %d on queue %d",tid,qid)); end-if
  send(CMD_OK,tid)
  updatequeue(qid)
 end-if
end-procedure

! Retrieve pending tasks for a queue
procedure cmd_getpending(qid:integer)
 if not exists(queues(qid)) then
  logmsg(formattext("Invalid queue ID %d",qid))
  send(CMD_ERR,0)
 else
  send(CMD_OK,getpending(qid))
 end-if
end-procedure

! Flush pending tasks
procedure cmd_queueflush(qid:integer)
 if not exists(queues(qid)) then
  logmsg(formattext("Invalid queue ID %d",qid))
  send(CMD_ERR,0)
 else
  queue_flush(qid)
  send(CMD_OK,0)
 end-if
end-procedure

! Reset a queue (only possible if no tasks are being processed)
procedure cmd_queuereset(qid:integer)
 if not exists(queues(qid)) then
  logmsg(formattext("Invalid queue ID %d",qid))
  send(CMD_ERR,0)
 else
  send(CMD_OK,queue_reset(qid))
 end-if
end-procedure

! Free (=delete) all tasks associated with a queue
procedure cmd_taskfrque(qid:integer)
 if not exists(queues(qid)) then
  logmsg(formattext("Invalid queue ID %d",qid))
  send(CMD_ERR,0)
 else
  send(CMD_OK,task_frque(qid))
 end-if
end-procedure

! Cancel execution of a task
procedure cmd_taskcancel(tid:integer)
 if exists(tasks(tid)) then
  with t=tasks(tid), qid=t.qid, q=queues(qid) do
   if t.status=RT_RUNNING then
    if jqverb>1 then logmsg(formattext("Task %d stopped",tid)); end-if
    send(q.workers(t.wid).mo,333,0)
   elif t.status=RT_PENDING then
    if jqverb>1 then logmsg(formattext("Task %d removed from queue %d",tid,qid)); end-if
    tp:=findfirst(q.mytasks,tid)
    if tp>0 then asproc(cutelt(q.mytasks,tp)); end-if
    settaskstat(tid,RT_CANCELLED,"")
   end-if
  end-do
 end-if
 send(CMD_OK,0)
end-procedure

! Restart the execution of a task
procedure cmd_taskrest(tid:integer)
 if exists(tasks(tid)) then
  with t=tasks(tid), qid=t.qid do
   if t.status<>RT_RUNNING and t.status<>RT_PENDING then
    t.nbexec:=0
    queues(qid).mytasks+=[tid]
    settaskstat(tid,RT_PENDING,"")
    if jqverb>1 then logmsg(formattext("Task %d scheduled on queue %d",tid,qid)); end-if
    needrefresh:=true
   end-if
  end-do
 end-if
 send(CMD_OK,0)
 if needrefresh then
  updatequeue(tasks(tid).qid)
 end-if
end-procedure

! Retrieve information about a queue
procedure cmd_queueinfo(qid:integer)
 declarations
  jqi: jq_qinfo
 end-declarations

 if not exists(queues(qid)) then
  logmsg(formattext("Invalid queue ID %d",qid))
  send(CMD_ERR,0)
 else
  with q=queues(qid) do
   jqi.nbwk:=q.workers.size
   jqi.nbdis:=q.nbdisabled
   jqi.pending:=q.mytasks
   if not isqueueidle(qid) then
    forall(wid in 1..jqi.nbwk|q.workers(wid).tid>0)
     jqi.running+=[q.workers(wid).tid]
   end-if
  end-do
  initialisations to msgfile
   jqi
  end-initialisations
  send(CMD_OK,0)
 end-if
end-procedure
!---------------------------------------------------------
! Release a task
procedure task_free(tid:integer)
 if exists(tasks(tid)) and tasks(tid).status<>RT_RUNNING then
  with t=tasks(tid), qid=t.qid, q=queues(qid) do
   if t.status=RT_PENDING then
    tp:=findfirst(q.mytasks,tid)
    if tp>0 then asproc(cutelt(q.mytasks,tp)); end-if
   end-if
  end-do
  fdelete(taskoutfile(tid))
  fdelete(taskerrfile(tid))
  fdelete(taskresfile(tid))
  fdelete(taskstatfile(tid))
  fdelete(taskhostfile(tid))
  delcell(tasks(tid))
  if jqverb>1 then logmsg(formattext("Task %d deleted",tid)); end-if
 end-if
end-procedure

! Flush a queue (i.e. delete all pending tasks)
procedure queue_flush(qid:integer)
 with q=queues(qid) do
  forall(tid in q.mytasks) do
   if jqverb>1 then logmsg(formattext("Task %d cancelled",tid)); end-if
   tasks(tid).status:=RT_OK
   task_free(tid)
  end-do
  reset(q.mytasks)
 end-do
end-procedure

! Reset a queue (i.e. flush and disconnect all nodes)
function queue_reset(qid:integer):integer
 queue_flush(qid)
 if isqueueidle(qid) then
  with q=queues(qid) do
   returned:=0
   forall(nid in 1..q.nodes.size,n=q.nodes(nid)) do
    if jqverb>1 then logmsg(formattext("Disconnecting node %d/%d",qid,nid)); end-if
    if n.mi.status=0 then
     disconnect(n.mi)
    end-if
    n.disabled:=false
    n.banner:=""
    n.info:=""
   end-do
   forall(wid in 1..q.workers.size)
    q.workers(wid).tid:=0
   q.nbwk:=q.workers.size
   q.nbdisabled:=0
   q.lastused:=0
  end-do
 else
  returned:=1
 end-if
end-function

! Release all tasks associated to a queue
function task_frque(qid:integer):integer
 queue_flush(qid)
 forall(tid in 1..tasks.size| exists(tasks(tid)) and tasks(tid).qid=qid)
  if tasks(tid).status<>RT_RUNNING then
   todel+=[tid]
  else
   returned+=1
  end-if
 forall(tid in todel)
  task_free(tid)
end-function

! Return the number of tasks waiting in a queue
function getpending(qid:integer):integer
 with q=queues(qid) do
  returned:=q.mytasks.size+q.workers.size-q.nbwk-q.nbdisabled
  if returned>0 and q.workers.size-q.nbdisabled=0 then
   returned:=-returned
  end-if
 end-do
end-function

! Change the status of a task
procedure settaskstat(tid:integer,status:integer,msg:text)
 initialisations to taskstatfile(tid)
  evaluation of status as "status"
  evaluation of 0 as "code"
 end-initialisations
 if msg<>"" then
  if jqverb>1 then logmsg(formattext("Task %d cancelled:%s",tid,msg)); end-if
  fopen(taskerrfile(tid),F_APPEND)
  writeln("JobQueue: ",msg)
  fclose(F_OUTPUT)
 end-if
 tasks(tid).status:=status
end-procedure

! Process an end-event
function processend(evt:Event):integer
 tid:=evt.fromuid
 if not exists(tasks(tid)) then
  logmsg("Received an unexpected event end - ignoring it")
  returned:=-MAX_INT
 else
  with t=tasks(tid), qid=t.qid, q=queues(qid), wid=t.wid,
       runlocal=(q.nodes(q.workers(wid).nid).cstr="*"),
       mo=q.workers(wid).mo,mi=q.nodes(q.workers(wid).nid).mi do
   if jqverb>1 then logmsg(formattext("Task %d running on worker %d/%d/%d has finished (exit:%g/%d)",tid,qid,q.workers(wid).nid,wid,evt.value,mo.exitcode)); end-if
   returned:=qid
   t.wid:=0
   q.workers(wid).tid:=0
   q.nbwk+=1
   rmtpath:=if(runlocal,text("tmp:"),text("rmt:[")+mi.id+"]tmp:")
   fcopy(rmtpath+"out_"+JQID+"_"+tid,0,taskoutfile(tid),F_APPEND)
   fcopy(rmtpath+"err_"+JQID+"_"+tid,0,taskerrfile(tid),F_APPEND)
   if t.job.resultfile<>"" then
    fcopy(rmtpath+"wd_"+JQID+"_"+tid+"/"+t.job.resultfile,taskresfile(tid))
   end-if
   if evt.value=0 then
    t.status:=mo.exitcode
   else
    settaskstat(tid,integer(evt.value),"")
   end-if

   if mo.status=RT_FDCLOSED then
    if jqverb>1 then logmsg(formattext("Lost connection to worker %d/%d/%d",tid,qid,q.workers(wid).nid)); end-if
    fopen(taskerrfile(tid),F_APPEND)
    writeln("JobQueue: Lost connection to worker ",tid,"/",qid,"/",q.workers(wid).nid)
    if t.nbexec<t.job.maxretry then
     writeln("JobQueue: Scheduling task for attempt #",t.nbexec+1,"/",t.job.maxretry)
     if jqverb>1 then logmsg(formattext("Task %d scheduled on queue %d (#%d/%d)",tid,qid,t.nbexec+1,t.job.maxretry)); end-if
     queues(qid).mytasks+=[tid]
     settaskstat(tid,RT_PENDING,"")
    end-if
    fclose(F_OUTPUT)
   else
    ctrl_cleanup(mo,tid)
   end-if
   updatequeue(qid)
  end-do
 end-if
end-function

! Cleanup a ctrl model
procedure ctrl_cleanup(mo:Model,tid:integer)
 declarations
  rtparms:text
 end-declarations

 if mo.status<>RT_FDCLOSED and mo.status<>RT_NOTINIT then
  setdefstream(mo,"null:","null:","null:")
  setmodpar(rtparms,"CMD",1)
  setmodpar(rtparms,"ID",JQID+"_"+tid)
  run(mo,rtparms)
  waitforend(mo)
  unload(mo)
 end-if
end-procedure

! Update a queue by trying to start as many tasks as possibme
procedure updatequeue(qid:integer)
 repeat
  cnt:=runqueue(qid)
 until not cnt
end-procedure

! Try to run the next task of a queue
function runqueue(qid:integer):boolean
 declarations
  rtparms:text
 end-declarations
 if queues(qid).mytasks.size>0 then
  wid:=findworker(qid)
  if wid>0 then
   with q=queues(qid) do
    ! skip all workers on the same node for next execution
    q.lastused:=q.nodes(q.workers(wid).nid).wids.last
    returned:=true
    tid:=cutfirst(q.mytasks)
    with mo=q.workers(wid).mo,mi=q.nodes(q.workers(wid).nid).mi,
         runlocal=(q.nodes(q.workers(wid).nid).cstr="*"),
         t=tasks(tid) do
     localsetparam("ioctrl",true)
     if runlocal then
      load(mo,"shmem:ctrl_bim")
     else
      load(mi,mo,"shmem:ctrl_bim")
     end-if
     if getparam("iostatus")<>0 then
      settaskstat(tid,RT_SYSERR,"Failed to load 'ctrl'!")
     else
      setdefstream(mo,"null:","tmp:out_"+JQID+"_"+tid,"tmp:err_"+JQID+"_"+tid)
      setmodpar(rtparms,"CMD",0)
      setmodpar(rtparms,"ID",JQID+"_"+tid)
      run(mo,rtparms)
      waitforend(mo)
      if mo.status<>RT_OK or mo.exitcode<>0 then
       settaskstat(tid,RT_SYSERR,"Failed to run 'ctrl'!")
       unload(mo)
      else
       rmtdir:=if(runlocal,text("tmp:"),text("rmt:[")+mi.id+"]tmp:")+
       			"wd_"+JQID+"_"+tid

       forall(f in 1..t.job.srcfiles.size) do
        fcopy(t.job.srcfiles(f),rmtdir+"/"+t.job.dstfiles(f))
        if getsysstat<>0 then
         settaskstat(tid,RT_FCPYERR,text("Failed to copy '")+t.job.srcfiles(f)+"'")
         break
        end-if
       end-do
       if t.status=RT_PENDING then
        if jqverb>1 then logmsg(formattext("Task %d starting on worker %d/%d/%d",tid,qid,q.workers(wid).nid,wid)); end-if
        setuid(mo,tid)
        t.wid:=wid
        q.workers(wid).tid:=tid
        q.nbwk-=1
        setworkdir(mo,"tmp:wd_"+JQID+"_"+tid)
        setmodpar(rtparms,"CMD",2)
        setmodpar(rtparms,"FNAME",t.job.dstfiles.first)
        setmodpar(rtparms,"RTPARMS",t.rtparms)
        setmodpar(rtparms,"STSFILE",text("rmt:[")+getparam("nodenumber")+"]"+taskstatfile(tid))
        settaskstat(tid,RT_RUNNING,"")
        initialisations to taskhostfile(tid)
         qid
         wid
         evaluation of q.workers(wid).nid as "nid"
         evaluation of q.nodes(q.workers(wid).nid).info as "sysinfo"
         evaluation of q.nodes(q.workers(wid).nid).banner as "banner"
        end-initialisations
	t.nbexec+=1
        run(mo,rtparms)
       else
        ctrl_cleanup(mo,tid)
       end-if
      end-if
     end-if
    end-do
   end-do
  end-if
 end-if
end-function

! Check whether a queue is doing anything
function isqueueidle(qid:integer):boolean
 with q=queues(qid) do
  returned:=q.nbwk+q.nbdisabled=q.workers.size
 end-do
end-function

!---------------------------------------------------------
! Disable a node
procedure disablenode(qid:integer,nid:integer)
 with q=queues(qid),qn=q.nodes(nid) do
  qn.disabled:=true
  forall(w in qn.wids)
   q.workers(w).tid:=-1
  q.nbdisabled+=qn.wids.size
  q.nbwk-=qn.wids.size
  logmsg(formattext("Failed to start node %d/%d(%s): disabling %d workers",qid,nid,qn.cstr,qn.wids.size))
 end-do
end-procedure

! Check if a node is ready and try to connect if necessary
function nodeready(qid:integer,nid:integer):boolean
 returned:=true
 with q=queues(qid),qn=q.nodes(nid) do
  if qn.disabled then
   logmsg(formattext("Trying to restart node %d/%d(%s) - ignored",qid,nid,qn.cstr))
   returned:=false
  elif qn.cstr="*" then
   if qn.banner="" then
    if jqverb>1 then logmsg(formattext("Connecting node %d/%d(%s)",qid,nid,qn.cstr)); end-if
    qn.banner:="FICO Xpress Mosel v"+versionstr("")
    qn.info:=getsysinfo
   end-if
  elif qn.mi.status<>0 then
   disconnect(qn.mi)  ! in case we lost connection before
   if jqverb>1 then logmsg(formattext("Connecting node %d/%d(%s)",qid,nid,qn.cstr)); end-if
   if connect(qn.mi,qn.cstr)<>0 then
    disablenode(qid,nid)
    returned:=false
   else
    ! Now let's try to compile/upload ctrl.mos:
    ! The source file is sent in compressed form
    fcopy(jqctrl_src_gz,"rmt:["+qn.mi.id+"]tmp:ctrl.mos.dfl")
    ! Compile from compressed source to shared memory
    if compile(qn.mi,COMPFLG,"zlib.deflate:tmp:ctrl.mos.dfl","shmem:ctrl_bim")<>0 then
     if jqverb>1 then logmsg(formattext("Failed to compile ctr.mos on node %d/%d",qid,nid)); end-if
     disconnect(qn.mi)
     disablenode(qid,nid)
     returned:=false
    else
     qn.banner:=getbanner(qn.mi)
     qn.info:=getsysinfo(qn.mi)
    end-if
   end-if
  end-if
 end-do
end-function

! Try to find a worker
! -1:no worker at all, 0:all workers busy, >0:wid
function findworker(qid:integer):integer
 with q=queues(qid) do
  if q.workers.size-q.nbdisabled<1 then
   returned:=-1    ! no worker in this queue
  elif q.nbwk<1 then
   returned:=0     ! no worker available
  else
   w:=q.lastused+1
   if w<=q.workers.size then
    repeat
     while(w<=q.workers.size and q.workers(w).tid<>0) do w+=1; end-do
    until w>q.workers.size or nodeready(qid,q.workers(w).nid)
    if w>q.workers.size then w:=1; end-if
   else
    w:=1
   end-if

   repeat
    while(w<=q.workers.size and q.workers(w).tid<>0) do w+=1; end-do
   until w>q.workers.size or nodeready(qid,q.workers(w).nid)
   if w<=q.workers.size and q.workers(w).tid=0 then
    returned:=w
   else
    returned:=if(q.workers.size-q.nbdisabled<1,-1,0)
   end-if
  end-if
 end-do
end-function

!--------------------------------------------------------- program starts here
jqinit(JQID)
setparam("workdir",string(expandpath(wkdir)))
! Remove the compression prefix from the filename of the datablock in memory
! to keep the file compressed when copying it to the workers
jqctrl_src_gz:=substr(datablock("jqctrl.mos","zlib.deflate:"),14,100)
! Also compile controler model locally if it is not yet present in memory
if getfsize("shmem:ctrl_bim")<16 and 
   compile(COMPFLG,datablock("jqctrl.mos"),"shmem:ctrl_bim")<>0 then
 logmsg("Failed to compile ctrl.mos")
 exit(1)
end-if
send(CMD_OK,0)       ! Notify main (user model) that the scheduler is ready

! Now launch the scheduler
waiting:=-1
once:=false
timer:=-1
repeat
 wait
 evt:=getnextevent
 if evt.fromid=0 then     ! a command or timer
  case evt.class of
   EVENT_TIMER: if timer>=0 then
                 send(CMD_OK,getpending(waiting))
                 waiting:=-1
		 timer:=-1
		end-if
		! else: queue empty before time expiration
   CMD_END    : finished:=true
   CMD_VERBOSE: do
   		 jqverb:=integer(evt.value)
                 send(CMD_OK,0)
		end-do
   CMD_NEWQUEUE: cmd_newqueue
   CMD_NEWNODE:  cmd_newnode(integer(evt.value))
   CMD_NEWTASK:  cmd_newtask(integer(evt.value))
   CMD_QUEPEND:  cmd_getpending(integer(evt.value))
   CMD_QUEWAIT: if timer>=0 or waiting>=0 then
		 logmsg("Internal error - exiting")
		 exit(1)
		else
		 with qp=getpending(integer(evt.value)) do
		  if qp<=0 then
		   send(CMD_OK,qp)
		  else
		   initialisations from msgfile
		    maxtime once
		   end-initialisations
		   if maxtime>0 then
		    timer:=settimer(-1,round(maxtime*1000),false)
		   end-if
		   waiting:=integer(evt.value)
		  end-if
		 end-do
		end-if
   CMD_TSKFREE: do task_free(integer(evt.value)); send(CMD_OK,0); end-do
   CMD_QUEFLUS: cmd_queueflush(integer(evt.value))
   CMD_QUEREST: cmd_queuereset(integer(evt.value))
   CMD_TSKFQUE: cmd_taskfrque(integer(evt.value))
   CMD_TSKCANC: cmd_taskcancel(integer(evt.value))
   CMD_DELQUEUE:cmd_delqueue(integer(evt.value))
   CMD_TSKREST: cmd_taskrest(integer(evt.value))
   CMD_QINFO:   cmd_queueinfo(integer(evt.value))
   else
    logmsg(formattext("Event %s ignored",evt))
  end-case
 elif evt.class=EVENT_END then ! end of a submodel
  if processend(evt)=waiting and (once or getpending(waiting)<=0) then
   send(CMD_OK,getpending(waiting))
   waiting:=-1
   once:=false
   if timer>=0 then
    canceltimer(timer)
    timer:=-1
   end-if
  end-if
 end-if                   ! everything else is ignored
until finished
if jqverb>1 then logmsg("Scheduler terminating"); end-if
end-model
